/**
 * Generated by orval v6.9.6 ðŸº
 * Do not edit manually.
 * Enterprise Deepchecks Monitoring
 * OpenAPI spec version: 0.1.0
 */
import { useQuery, useMutation } from '@tanstack/react-query';
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey
} from '@tanstack/react-query';
import { customInstance } from '../services/customAxios';
import type { ErrorType } from '../services/customAxios';
export type SlackInstallationCallbackApiV1SlackInstallGetParams = { code: string; error?: string; state?: string };

export type GetModelColumnsApiV1ModelsModelIdColumnsGet200 = { [key: string]: ColumnMetadata };

export type RetrieveModelsDataIngestionApiV1ModelsDataIngestionGet200 = { [key: string]: ModelDailyIngestion[] };

export type RetrieveModelsDataIngestionApiV1ModelsDataIngestionGetParams = {
  model_id?: number;
  time_filter?: number;
  end_time?: string;
};

export type RetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGetParams = {
  time_filter?: number;
  end_time?: string;
};

export type UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutBodyItem = { [key: string]: any };

export type LogDataBatchApiV1ModelVersionsModelVersionIdDataPostBodyItem = { [key: string]: any };

export type GetAllAlertRulesApiV1ConfigAlertRulesGetSortbyItem =
  typeof GetAllAlertRulesApiV1ConfigAlertRulesGetSortbyItem[keyof typeof GetAllAlertRulesApiV1ConfigAlertRulesGetSortbyItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetAllAlertRulesApiV1ConfigAlertRulesGetSortbyItem = {
  severityasc: 'severity:asc',
  severitydesc: 'severity:desc'
} as const;

export type GetAllAlertRulesApiV1ConfigAlertRulesGetParams = {
  models?: number[];
  severity?: AlertSeverity[];
  sortby?: GetAllAlertRulesApiV1ConfigAlertRulesGetSortbyItem[];
};

export type DeleteCheckByNameApiV1ModelsModelIdChecksDeleteParams = { names: string[] };

export type CreateCheckApiV1ModelsModelIdChecksPost200 = IdResponse | IdResponse[];

export type CreateCheckApiV1ModelsModelIdChecksPostBody = CheckCreationSchema | CheckCreationSchema[];

export type GetAlertRulesApiV1AlertRulesGetSortbyItem =
  typeof GetAlertRulesApiV1AlertRulesGetSortbyItem[keyof typeof GetAlertRulesApiV1AlertRulesGetSortbyItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetAlertRulesApiV1AlertRulesGetSortbyItem = {
  severityasc: 'severity:asc',
  severitydesc: 'severity:desc',
  'alert-windowasc': 'alert-window:asc',
  'alert-windowdesc': 'alert-window:desc'
} as const;

export type GetAlertRulesApiV1AlertRulesGetParams = {
  monitor_id?: number;
  start?: string;
  end?: string;
  models?: number[];
  severity?: AlertSeverity[];
  is_active?: boolean;
  sortby?: GetAlertRulesApiV1AlertRulesGetSortbyItem[];
};

export type CountAlertRulesApiV1AlertRulesCountGet200 = { [key: string]: number };

export type CountAlertRulesApiV1AlertRulesCountGetParams = { model_id?: number };

export type CountAlertRulesApiV1ModelsModelIdAlertRulesCountGet200 = { [key: string]: number };

export type GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetSortbyItem =
  typeof GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetSortbyItem[keyof typeof GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetSortbyItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetSortbyItem = {
  severityasc: 'severity:asc',
  severitydesc: 'severity:desc',
  'alert-windowasc': 'alert-window:asc',
  'alert-windowdesc': 'alert-window:desc'
} as const;

export type GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetParams = {
  start?: string;
  end?: string;
  models?: number[];
  severity?: AlertSeverity[];
  is_active?: boolean;
  sortby?: GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetSortbyItem[];
};

export type CountAlertsApiV1AlertsCountActiveGet200 = { [key: string]: number };

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export interface UserSchema {
  id: number;
  email: string;
  created_at: string;
  full_name?: string;
  picture_url?: string;
  organization?: OrganizationSchema;
}

/**
 * Enum containing supported task types.
 */
export type TaskType = unknown;

export interface OrganizationUpdateSchema {
  slack_notification_levels?: AlertSeverity[];
  email_notification_levels?: AlertSeverity[];
}

export interface OrganizationSchema {
  id: number;
  name: string;
}

/**
 * Operators for numeric and categorical filters.
 */
export type OperatorsEnum = typeof OperatorsEnum[keyof typeof OperatorsEnum];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OperatorsEnum = {
  greater_than_equals: 'greater_than_equals',
  greater_than: 'greater_than',
  less_than_equals: 'less_than_equals',
  less_than: 'less_than',
  contains: 'contains',
  equals: 'equals',
  not_equals: 'not_equals'
} as const;

/**
 * Schema defines a response containing only id and name.
 */
export interface NameIdResponse {
  id: number;
  name: string;
}

/**
 * List of data filters.
 */
export interface MonitorValueConf {
  name: string;
  is_agg?: boolean;
}

/**
 * List of data filters.
 */
export interface MonitorTypeConf {
  type: string;
  values?: MonitorValueConf[];
  is_agg_shown?: boolean;
}

/**
 * Schema for the monitor.
 */
export interface MonitorSchema {
  id: number;
  name: string;
  check: CheckSchema;
  dashboard_id?: number;
  lookback: number;
  aggregation_window: number;
  description?: string;
  data_filters?: DataFilterList;
  additional_kwargs?: MonitorCheckConfSchema;
  alert_rules: AlertRuleSchema[];
  frequency: number;
}

/**
 * Schema defines the parameters for creating new monitor.
 */
export interface MonitorRunSchema {
  end_time?: string;
}

export type MonitorCheckConfSchemaCheckConf = { [key: string]: any };

/**
 * List of data filters.
 */
export interface MonitorCheckConfSchema {
  check_conf: MonitorCheckConfSchemaCheckConf;
  res_conf?: string[];
}

/**
 * Schema defines the parameters for creating new monitor.
 */
export interface MonitorUpdateSchema {
  name?: string;
  lookback?: number;
  description?: string;
  data_filters?: DataFilterList;
  dashboard_id?: number;
  additional_kwargs?: MonitorCheckConfSchema;
  frequency?: number;
  aggregation_window?: number;
}

/**
 * Monitor run schema.
 */
export interface MonitorOptions {
  end_time: string;
  start_time: string;
  frequency?: number;
  aggregation_window?: number;
  filter?: DataFilterList;
  additional_kwargs?: MonitorCheckConfSchema;
}

/**
 * Schema defines the parameters for creating new monitor.
 */
export interface MonitorCreationSchema {
  name: string;
  lookback: number;
  aggregation_window: number;
  frequency: number;
  dashboard_id?: number;
  description?: string;
  data_filters?: DataFilterList;
  additional_kwargs?: MonitorCheckConfSchema;
}

/**
 * List of data filters.
 */
export interface MonitorCheckConf {
  check_conf?: MonitorTypeConf[];
  res_conf?: MonitorTypeConf;
}

/**
 * Model ingestion record.
 */
export interface ModelsInfoSchema {
  id: number;
  name: string;
  description?: string;
  task_type?: TaskType;
  alerts_count?: number;
  latest_time?: number;
}

export type ModelVersionCreationSchemaFeatureImportance = { [key: string]: number };

export type ModelVersionCreationSchemaNonFeatures = { [key: string]: ColumnType };

export type ModelVersionCreationSchemaFeatures = { [key: string]: ColumnType };

/**
 * Schema defines the parameters for creating new model version.
 */
export interface ModelVersionCreationSchema {
  name: string;
  features: ModelVersionCreationSchemaFeatures;
  non_features: ModelVersionCreationSchemaNonFeatures;
  feature_importance?: ModelVersionCreationSchemaFeatureImportance;
}

/**
 * Model Schema.
 */
export interface ModelSchema {
  id: number;
  name: string;
  description?: string;
  task_type?: TaskType;
}

export interface ModelDailyIngestion {
  count: number;
  day: number;
}

/**
 * Model schema.
 */
export interface ModelCreationSchema {
  name: string;
  description?: string;
  task_type: TaskType;
}

export interface MemberSchema {
  id: number;
  email: string;
  full_name?: string;
  disabled: boolean;
  picture_url?: string;
  is_admin: boolean;
  last_login?: string;
  created_at: string;
}

/**
 * Schema for info on invitation.
 */
export interface InvitationInfoSchema {
  from_user: string;
  org_name: string;
}

/**
 * Schema for the invitation creation.
 */
export interface InvitationCreationSchema {
  email: string;
  ttl?: number;
}

/**
 * Schema defines a response containing only id.
 */
export interface IdResponse {
  id: number;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * Filter to be used on data, column can be feature/non-feature and value can be numeric/string.
 */
export interface DataFilter {
  column: string;
  operator: OperatorsEnum;
  value?: unknown;
}

/**
 * List of data filters.
 */
export interface DataFilterList {
  filters: DataFilter[];
}

/**
 * Schema defines the parameters for updating a dashboard.
 */
export interface DashboardUpdateSchema {
  name: string;
}

/**
 * Schema for the dashboard.
 */
export interface DashboardSchema {
  id: number;
  name?: string;
  monitors: MonitorSchema[];
}

/**
 * Condition to define an alert on check result, value must be numeric.
 */
export interface Condition {
  operator: OperatorsEnum;
  value: number;
}

/**
 * Schema for to update complete details page.
 */
export interface CompleteDetailsUpdateSchema {
  new_organization_name?: string;
  user_full_name?: string;
  accept_invite?: boolean;
}

/**
 * Schema for complete details page.
 */
export interface CompleteDetailsSchema {
  invitation?: InvitationInfoSchema;
  user_full_name?: string;
  organization_name?: string;
}

/**
 * Enum containing possible types of data.
 */
export type ColumnType = typeof ColumnType[keyof typeof ColumnType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ColumnType = {
  numeric: 'numeric',
  integer: 'integer',
  categorical: 'categorical',
  boolean: 'boolean',
  text: 'text',
  array_float: 'array_float',
  array_float_2d: 'array_float_2d',
  datetime: 'datetime'
} as const;

/**
 * A typed object represents a numeric column statistic.
 */
export interface ColumnStatistics {
  max?: number;
  min?: number;
  values?: string[];
}

/**
 * TypedDict containing relavant column metadata.
 */
export interface ColumnMetadata {
  type: ColumnType;
  stats: ColumnStatistics;
}

export type CheckResultSchemaOutput = { [key: string]: any };

/**
 * Check run result schema.
 */
export interface CheckResultSchema {
  output: CheckResultSchemaOutput;
  time_labels: string[];
}

export type CheckConfigSchemaParams = { [key: string]: any };

export interface CheckConfigSchema {
  module_name: string;
  class_name: string;
  params: CheckConfigSchemaParams;
}

/**
 * Schema for the check.
 */
export interface CheckSchema {
  config: CheckConfigSchema;
  model_id: number;
  id: number;
  name?: string;
}

/**
 * Check schema.
 */
export interface CheckCreationSchema {
  config: CheckConfigSchema;
  name?: string;
}

export interface BodySaveReferenceApiV1ModelVersionsModelVersionIdReferencePost {
  file: Blob;
}

/**
 * Enum for the alert severity.
 */
export type AlertSeverity = typeof AlertSeverity[keyof typeof AlertSeverity];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AlertSeverity = {
  low: 'low',
  mid: 'mid',
  high: 'high',
  critical: 'critical'
} as const;

export type AlertSchemaFailedValues = { [key: string]: string[] };

/**
 * Schema for the alert.
 */
export interface AlertSchema {
  id: number;
  alert_rule_id: number;
  failed_values: AlertSchemaFailedValues;
  start_time: string;
  end_time: string;
  resolved: boolean;
  created_at: string;
}

/**
 * Schema defines the parameters for updating alert rule.
 */
export interface AlertRuleUpdateSchema {
  alert_severity?: AlertSeverity;
  condition?: Condition;
  is_active?: boolean;
}

/**
 * Schema for the alert rule.
 */
export interface AlertRuleSchema {
  id: number;
  monitor_id: number;
  condition: Condition;
  alert_severity?: AlertSeverity;
  is_active: boolean;
}

/**
 * Schema of alert rule info for display.
 */
export interface AlertRuleInfoSchema {
  id: number;
  monitor_id: number;
  condition: Condition;
  alert_severity?: AlertSeverity;
  is_active: boolean;
  model_id: number;
  alerts_count?: number;
  max_end_time: string;
}

/**
 * Schema defines the parameters for creating new alert rule.
 */
export interface AlertRuleCreationSchema {
  condition: Condition;
  alert_severity?: AlertSeverity;
  is_active?: boolean;
}

/**
 * Schema for the alert rule.
 */
export interface AlertRuleConfigSchema {
  id: number;
  name: string;
  check_name: string;
  frequency: number;
  alert_severity?: AlertSeverity;
  total_alerts?: number;
  non_resolved_alerts?: number;
  recent_alert?: string;
}

/**
 * @summary Hello World
 */
export const helloWorldApiV1SayHelloGet = (signal?: AbortSignal) =>
  customInstance<unknown>({ url: `/api/v1/say-hello`, method: 'get', signal });

export const getHelloWorldApiV1SayHelloGetQueryKey = () => [`/api/v1/say-hello`];

export type HelloWorldApiV1SayHelloGetQueryResult = NonNullable<Awaited<ReturnType<typeof helloWorldApiV1SayHelloGet>>>;
export type HelloWorldApiV1SayHelloGetQueryError = ErrorType<unknown>;

export const useHelloWorldApiV1SayHelloGet = <
  TData = Awaited<ReturnType<typeof helloWorldApiV1SayHelloGet>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof helloWorldApiV1SayHelloGet>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHelloWorldApiV1SayHelloGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof helloWorldApiV1SayHelloGet>>> = ({ signal }) =>
    helloWorldApiV1SayHelloGet(signal);

  const query = useQuery<Awaited<ReturnType<typeof helloWorldApiV1SayHelloGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Count alerts.
 * @summary Count Alerts
 */
export const countAlertsApiV1AlertsCountActiveGet = (signal?: AbortSignal) =>
  customInstance<CountAlertsApiV1AlertsCountActiveGet200>({
    url: `/api/v1/alerts/count_active`,
    method: 'get',
    signal
  });

export const getCountAlertsApiV1AlertsCountActiveGetQueryKey = () => [`/api/v1/alerts/count_active`];

export type CountAlertsApiV1AlertsCountActiveGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof countAlertsApiV1AlertsCountActiveGet>>
>;
export type CountAlertsApiV1AlertsCountActiveGetQueryError = ErrorType<unknown>;

export const useCountAlertsApiV1AlertsCountActiveGet = <
  TData = Awaited<ReturnType<typeof countAlertsApiV1AlertsCountActiveGet>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof countAlertsApiV1AlertsCountActiveGet>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCountAlertsApiV1AlertsCountActiveGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countAlertsApiV1AlertsCountActiveGet>>> = ({ signal }) =>
    countAlertsApiV1AlertsCountActiveGet(signal);

  const query = useQuery<Awaited<ReturnType<typeof countAlertsApiV1AlertsCountActiveGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Resolve alert by id.
 * @summary Resolve Alert
 */
export const resolveAlertApiV1AlertsAlertIdResolvePost = (alertId: number) =>
  customInstance<unknown>({ url: `/api/v1/alerts/${alertId}/resolve`, method: 'post' });

export type ResolveAlertApiV1AlertsAlertIdResolvePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof resolveAlertApiV1AlertsAlertIdResolvePost>>
>;

export type ResolveAlertApiV1AlertsAlertIdResolvePostMutationError = ErrorType<HTTPValidationError>;

export const useResolveAlertApiV1AlertsAlertIdResolvePost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resolveAlertApiV1AlertsAlertIdResolvePost>>,
    TError,
    { alertId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resolveAlertApiV1AlertsAlertIdResolvePost>>,
    { alertId: number }
  > = props => {
    const { alertId } = props ?? {};

    return resolveAlertApiV1AlertsAlertIdResolvePost(alertId);
  };

  return useMutation<
    Awaited<ReturnType<typeof resolveAlertApiV1AlertsAlertIdResolvePost>>,
    TError,
    { alertId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Get alert by id.
 * @summary Get Alert
 */
export const getAlertApiV1AlertsAlertIdGet = (alertId: number, signal?: AbortSignal) =>
  customInstance<AlertSchema>({ url: `/api/v1/alerts/${alertId}`, method: 'get', signal });

export const getGetAlertApiV1AlertsAlertIdGetQueryKey = (alertId: number) => [`/api/v1/alerts/${alertId}`];

export type GetAlertApiV1AlertsAlertIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAlertApiV1AlertsAlertIdGet>>
>;
export type GetAlertApiV1AlertsAlertIdGetQueryError = ErrorType<HTTPValidationError>;

export const useGetAlertApiV1AlertsAlertIdGet = <
  TData = Awaited<ReturnType<typeof getAlertApiV1AlertsAlertIdGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  alertId: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getAlertApiV1AlertsAlertIdGet>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAlertApiV1AlertsAlertIdGetQueryKey(alertId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAlertApiV1AlertsAlertIdGet>>> = ({ signal }) =>
    getAlertApiV1AlertsAlertIdGet(alertId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getAlertApiV1AlertsAlertIdGet>>, TError, TData>(queryKey, queryFn, {
    enabled: !!alertId,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Delete alert by id.
 * @summary Delete Alert
 */
export const deleteAlertApiV1AlertsAlertIdDelete = (alertId: number) =>
  customInstance<unknown>({ url: `/api/v1/alerts/${alertId}`, method: 'delete' });

export type DeleteAlertApiV1AlertsAlertIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAlertApiV1AlertsAlertIdDelete>>
>;

export type DeleteAlertApiV1AlertsAlertIdDeleteMutationError = ErrorType<HTTPValidationError>;

export const useDeleteAlertApiV1AlertsAlertIdDelete = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAlertApiV1AlertsAlertIdDelete>>,
    TError,
    { alertId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAlertApiV1AlertsAlertIdDelete>>,
    { alertId: number }
  > = props => {
    const { alertId } = props ?? {};

    return deleteAlertApiV1AlertsAlertIdDelete(alertId);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteAlertApiV1AlertsAlertIdDelete>>,
    TError,
    { alertId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Create new alert rule on a given check.
 * @summary Create new alert rule on a given monitor.
 */
export const createAlertRuleApiV1MonitorsMonitorIdAlertRulesPost = (
  monitorId: number,
  alertRuleCreationSchema: AlertRuleCreationSchema
) =>
  customInstance<IdResponse>({
    url: `/api/v1/monitors/${monitorId}/alert-rules`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: alertRuleCreationSchema
  });

export type CreateAlertRuleApiV1MonitorsMonitorIdAlertRulesPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAlertRuleApiV1MonitorsMonitorIdAlertRulesPost>>
>;
export type CreateAlertRuleApiV1MonitorsMonitorIdAlertRulesPostMutationBody = AlertRuleCreationSchema;
export type CreateAlertRuleApiV1MonitorsMonitorIdAlertRulesPostMutationError = ErrorType<HTTPValidationError>;

export const useCreateAlertRuleApiV1MonitorsMonitorIdAlertRulesPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAlertRuleApiV1MonitorsMonitorIdAlertRulesPost>>,
    TError,
    { monitorId: number; data: AlertRuleCreationSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAlertRuleApiV1MonitorsMonitorIdAlertRulesPost>>,
    { monitorId: number; data: AlertRuleCreationSchema }
  > = props => {
    const { monitorId, data } = props ?? {};

    return createAlertRuleApiV1MonitorsMonitorIdAlertRulesPost(monitorId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof createAlertRuleApiV1MonitorsMonitorIdAlertRulesPost>>,
    TError,
    { monitorId: number; data: AlertRuleCreationSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Return all the alert rules.

Parameters
----------
start
end
models
severity
sortby
monitor_id : int
    ID of a monitor to filter alert rules by.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
List[AlertSchema]
    All the alerts for a given monitor.
 * @summary Get Alert Rules
 */
export const getAlertRulesApiV1MonitorsMonitorIdAlertRulesGet = (
  monitorId: number,
  params?: GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetParams,
  signal?: AbortSignal
) =>
  customInstance<AlertRuleInfoSchema[]>({
    url: `/api/v1/monitors/${monitorId}/alert-rules`,
    method: 'get',
    params,
    signal
  });

export const getGetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetQueryKey = (
  monitorId: number,
  params?: GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetParams
) => [`/api/v1/monitors/${monitorId}/alert-rules`, ...(params ? [params] : [])];

export type GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAlertRulesApiV1MonitorsMonitorIdAlertRulesGet>>
>;
export type GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetQueryError = ErrorType<HTTPValidationError>;

export const useGetAlertRulesApiV1MonitorsMonitorIdAlertRulesGet = <
  TData = Awaited<ReturnType<typeof getAlertRulesApiV1MonitorsMonitorIdAlertRulesGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  monitorId: number,
  params?: GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAlertRulesApiV1MonitorsMonitorIdAlertRulesGet>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetQueryKey(monitorId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAlertRulesApiV1MonitorsMonitorIdAlertRulesGet>>> = ({
    signal
  }) => getAlertRulesApiV1MonitorsMonitorIdAlertRulesGet(monitorId, params, signal);

  const query = useQuery<Awaited<ReturnType<typeof getAlertRulesApiV1MonitorsMonitorIdAlertRulesGet>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!monitorId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Count alerts.
 * @summary Count Alert Rules
 */
export const countAlertRulesApiV1ModelsModelIdAlertRulesCountGet = (modelId: number, signal?: AbortSignal) =>
  customInstance<CountAlertRulesApiV1ModelsModelIdAlertRulesCountGet200>({
    url: `/api/v1/models/${modelId}/alert-rules/count`,
    method: 'get',
    signal
  });

export const getCountAlertRulesApiV1ModelsModelIdAlertRulesCountGetQueryKey = (modelId: number) => [
  `/api/v1/models/${modelId}/alert-rules/count`
];

export type CountAlertRulesApiV1ModelsModelIdAlertRulesCountGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof countAlertRulesApiV1ModelsModelIdAlertRulesCountGet>>
>;
export type CountAlertRulesApiV1ModelsModelIdAlertRulesCountGetQueryError = ErrorType<HTTPValidationError>;

export const useCountAlertRulesApiV1ModelsModelIdAlertRulesCountGet = <
  TData = Awaited<ReturnType<typeof countAlertRulesApiV1ModelsModelIdAlertRulesCountGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  modelId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof countAlertRulesApiV1ModelsModelIdAlertRulesCountGet>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCountAlertRulesApiV1ModelsModelIdAlertRulesCountGetQueryKey(modelId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countAlertRulesApiV1ModelsModelIdAlertRulesCountGet>>> = ({
    signal
  }) => countAlertRulesApiV1ModelsModelIdAlertRulesCountGet(modelId, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof countAlertRulesApiV1ModelsModelIdAlertRulesCountGet>>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!modelId, ...queryOptions }) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * Count alerts.
 * @summary Count Alert Rules
 */
export const countAlertRulesApiV1AlertRulesCountGet = (
  params?: CountAlertRulesApiV1AlertRulesCountGetParams,
  signal?: AbortSignal
) =>
  customInstance<CountAlertRulesApiV1AlertRulesCountGet200>({
    url: `/api/v1/alert-rules/count`,
    method: 'get',
    params,
    signal
  });

export const getCountAlertRulesApiV1AlertRulesCountGetQueryKey = (
  params?: CountAlertRulesApiV1AlertRulesCountGetParams
) => [`/api/v1/alert-rules/count`, ...(params ? [params] : [])];

export type CountAlertRulesApiV1AlertRulesCountGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof countAlertRulesApiV1AlertRulesCountGet>>
>;
export type CountAlertRulesApiV1AlertRulesCountGetQueryError = ErrorType<HTTPValidationError>;

export const useCountAlertRulesApiV1AlertRulesCountGet = <
  TData = Awaited<ReturnType<typeof countAlertRulesApiV1AlertRulesCountGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: CountAlertRulesApiV1AlertRulesCountGetParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof countAlertRulesApiV1AlertRulesCountGet>>, TError, TData>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCountAlertRulesApiV1AlertRulesCountGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countAlertRulesApiV1AlertRulesCountGet>>> = ({ signal }) =>
    countAlertRulesApiV1AlertRulesCountGet(params, signal);

  const query = useQuery<Awaited<ReturnType<typeof countAlertRulesApiV1AlertRulesCountGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Return all the alert rules.

Parameters
----------
start
end
models
severity
sortby
monitor_id : int
    ID of a monitor to filter alert rules by.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
List[AlertSchema]
    All the alerts for a given monitor.
 * @summary Get Alert Rules
 */
export const getAlertRulesApiV1AlertRulesGet = (params?: GetAlertRulesApiV1AlertRulesGetParams, signal?: AbortSignal) =>
  customInstance<AlertRuleInfoSchema[]>({ url: `/api/v1/alert-rules`, method: 'get', params, signal });

export const getGetAlertRulesApiV1AlertRulesGetQueryKey = (params?: GetAlertRulesApiV1AlertRulesGetParams) => [
  `/api/v1/alert-rules`,
  ...(params ? [params] : [])
];

export type GetAlertRulesApiV1AlertRulesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAlertRulesApiV1AlertRulesGet>>
>;
export type GetAlertRulesApiV1AlertRulesGetQueryError = ErrorType<HTTPValidationError>;

export const useGetAlertRulesApiV1AlertRulesGet = <
  TData = Awaited<ReturnType<typeof getAlertRulesApiV1AlertRulesGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: GetAlertRulesApiV1AlertRulesGetParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getAlertRulesApiV1AlertRulesGet>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAlertRulesApiV1AlertRulesGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAlertRulesApiV1AlertRulesGet>>> = ({ signal }) =>
    getAlertRulesApiV1AlertRulesGet(params, signal);

  const query = useQuery<Awaited<ReturnType<typeof getAlertRulesApiV1AlertRulesGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Get alert by id.
 * @summary Get Alert Rule
 */
export const getAlertRuleApiV1AlertRulesAlertRuleIdGet = (alertRuleId: number, signal?: AbortSignal) =>
  customInstance<AlertRuleSchema>({ url: `/api/v1/alert-rules/${alertRuleId}`, method: 'get', signal });

export const getGetAlertRuleApiV1AlertRulesAlertRuleIdGetQueryKey = (alertRuleId: number) => [
  `/api/v1/alert-rules/${alertRuleId}`
];

export type GetAlertRuleApiV1AlertRulesAlertRuleIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAlertRuleApiV1AlertRulesAlertRuleIdGet>>
>;
export type GetAlertRuleApiV1AlertRulesAlertRuleIdGetQueryError = ErrorType<HTTPValidationError>;

export const useGetAlertRuleApiV1AlertRulesAlertRuleIdGet = <
  TData = Awaited<ReturnType<typeof getAlertRuleApiV1AlertRulesAlertRuleIdGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  alertRuleId: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getAlertRuleApiV1AlertRulesAlertRuleIdGet>>, TError, TData>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAlertRuleApiV1AlertRulesAlertRuleIdGetQueryKey(alertRuleId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAlertRuleApiV1AlertRulesAlertRuleIdGet>>> = ({ signal }) =>
    getAlertRuleApiV1AlertRulesAlertRuleIdGet(alertRuleId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getAlertRuleApiV1AlertRulesAlertRuleIdGet>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!alertRuleId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Update alert by id.
 * @summary Update alert rule by id.
 */
export const updateAlertApiV1AlertRulesAlertRuleIdPut = (
  alertRuleId: number,
  alertRuleUpdateSchema: AlertRuleUpdateSchema
) =>
  customInstance<unknown>({
    url: `/api/v1/alert-rules/${alertRuleId}`,
    method: 'put',
    headers: { 'Content-Type': 'application/json' },
    data: alertRuleUpdateSchema
  });

export type UpdateAlertApiV1AlertRulesAlertRuleIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAlertApiV1AlertRulesAlertRuleIdPut>>
>;
export type UpdateAlertApiV1AlertRulesAlertRuleIdPutMutationBody = AlertRuleUpdateSchema;
export type UpdateAlertApiV1AlertRulesAlertRuleIdPutMutationError = ErrorType<HTTPValidationError>;

export const useUpdateAlertApiV1AlertRulesAlertRuleIdPut = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAlertApiV1AlertRulesAlertRuleIdPut>>,
    TError,
    { alertRuleId: number; data: AlertRuleUpdateSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAlertApiV1AlertRulesAlertRuleIdPut>>,
    { alertRuleId: number; data: AlertRuleUpdateSchema }
  > = props => {
    const { alertRuleId, data } = props ?? {};

    return updateAlertApiV1AlertRulesAlertRuleIdPut(alertRuleId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof updateAlertApiV1AlertRulesAlertRuleIdPut>>,
    TError,
    { alertRuleId: number; data: AlertRuleUpdateSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Delete alert by id.
 * @summary Delete Alert Rule
 */
export const deleteAlertRuleApiV1AlertRulesAlertRuleIdDelete = (alertRuleId: number) =>
  customInstance<unknown>({ url: `/api/v1/alert-rules/${alertRuleId}`, method: 'delete' });

export type DeleteAlertRuleApiV1AlertRulesAlertRuleIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAlertRuleApiV1AlertRulesAlertRuleIdDelete>>
>;

export type DeleteAlertRuleApiV1AlertRulesAlertRuleIdDeleteMutationError = ErrorType<HTTPValidationError>;

export const useDeleteAlertRuleApiV1AlertRulesAlertRuleIdDelete = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAlertRuleApiV1AlertRulesAlertRuleIdDelete>>,
    TError,
    { alertRuleId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAlertRuleApiV1AlertRulesAlertRuleIdDelete>>,
    { alertRuleId: number }
  > = props => {
    const { alertRuleId } = props ?? {};

    return deleteAlertRuleApiV1AlertRulesAlertRuleIdDelete(alertRuleId);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteAlertRuleApiV1AlertRulesAlertRuleIdDelete>>,
    TError,
    { alertRuleId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Delete alert by id.
 * @summary Get Alerts Of Alert Rule
 */
export const getAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGet = (alertRuleId: number, signal?: AbortSignal) =>
  customInstance<AlertSchema[]>({ url: `/api/v1/alert-rules/${alertRuleId}/alerts`, method: 'get', signal });

export const getGetAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGetQueryKey = (alertRuleId: number) => [
  `/api/v1/alert-rules/${alertRuleId}/alerts`
];

export type GetAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGet>>
>;
export type GetAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGetQueryError = ErrorType<HTTPValidationError>;

export const useGetAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGet = <
  TData = Awaited<ReturnType<typeof getAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  alertRuleId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGet>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGetQueryKey(alertRuleId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGet>>> = ({
    signal
  }) => getAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGet(alertRuleId, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof getAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGet>>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!alertRuleId, ...queryOptions }) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * Resolve all alerts of alert rule.
 * @summary Resolve All Alerts Of Alert Rule
 */
export const resolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPost = (alertRuleId: number) =>
  customInstance<unknown>({ url: `/api/v1/alert-rules/${alertRuleId}/resolve-all`, method: 'post' });

export type ResolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof resolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPost>>
>;

export type ResolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPostMutationError =
  ErrorType<HTTPValidationError>;

export const useResolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPost>>,
    TError,
    { alertRuleId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPost>>,
    { alertRuleId: number }
  > = props => {
    const { alertRuleId } = props ?? {};

    return resolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPost(alertRuleId);
  };

  return useMutation<
    Awaited<ReturnType<typeof resolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPost>>,
    TError,
    { alertRuleId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Create a new check.

Parameters
----------
model_id : int
    ID of the model.
check : CheckCreationSchema
    Check to create.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
int
    The check id.
 * @summary Create Check
 */
export const createCheckApiV1ModelsModelIdChecksPost = (
  modelId: number,
  createCheckApiV1ModelsModelIdChecksPostBody: CreateCheckApiV1ModelsModelIdChecksPostBody
) =>
  customInstance<CreateCheckApiV1ModelsModelIdChecksPost200>({
    url: `/api/v1/models/${modelId}/checks`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: createCheckApiV1ModelsModelIdChecksPostBody
  });

export type CreateCheckApiV1ModelsModelIdChecksPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createCheckApiV1ModelsModelIdChecksPost>>
>;
export type CreateCheckApiV1ModelsModelIdChecksPostMutationBody = CreateCheckApiV1ModelsModelIdChecksPostBody;
export type CreateCheckApiV1ModelsModelIdChecksPostMutationError = ErrorType<HTTPValidationError>;

export const useCreateCheckApiV1ModelsModelIdChecksPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCheckApiV1ModelsModelIdChecksPost>>,
    TError,
    { modelId: number; data: CreateCheckApiV1ModelsModelIdChecksPostBody },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCheckApiV1ModelsModelIdChecksPost>>,
    { modelId: number; data: CreateCheckApiV1ModelsModelIdChecksPostBody }
  > = props => {
    const { modelId, data } = props ?? {};

    return createCheckApiV1ModelsModelIdChecksPost(modelId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof createCheckApiV1ModelsModelIdChecksPost>>,
    TError,
    { modelId: number; data: CreateCheckApiV1ModelsModelIdChecksPostBody },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Delete check instances by name.
 * @summary Delete Check By Name
 */
export const deleteCheckByNameApiV1ModelsModelIdChecksDelete = (
  modelId: number,
  params: DeleteCheckByNameApiV1ModelsModelIdChecksDeleteParams
) => customInstance<unknown>({ url: `/api/v1/models/${modelId}/checks`, method: 'delete', params });

export type DeleteCheckByNameApiV1ModelsModelIdChecksDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteCheckByNameApiV1ModelsModelIdChecksDelete>>
>;

export type DeleteCheckByNameApiV1ModelsModelIdChecksDeleteMutationError = ErrorType<HTTPValidationError>;

export const useDeleteCheckByNameApiV1ModelsModelIdChecksDelete = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCheckByNameApiV1ModelsModelIdChecksDelete>>,
    TError,
    { modelId: number; params: DeleteCheckByNameApiV1ModelsModelIdChecksDeleteParams },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteCheckByNameApiV1ModelsModelIdChecksDelete>>,
    { modelId: number; params: DeleteCheckByNameApiV1ModelsModelIdChecksDeleteParams }
  > = props => {
    const { modelId, params } = props ?? {};

    return deleteCheckByNameApiV1ModelsModelIdChecksDelete(modelId, params);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteCheckByNameApiV1ModelsModelIdChecksDelete>>,
    TError,
    { modelId: number; params: DeleteCheckByNameApiV1ModelsModelIdChecksDeleteParams },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Return all the checks for a given model.

Parameters
----------
model_id : int
    ID of the model.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
List[CheckSchema]
    All the checks for a given model.
 * @summary Get Checks
 */
export const getChecksApiV1ModelsModelIdChecksGet = (modelId: number, signal?: AbortSignal) =>
  customInstance<CheckSchema[]>({ url: `/api/v1/models/${modelId}/checks`, method: 'get', signal });

export const getGetChecksApiV1ModelsModelIdChecksGetQueryKey = (modelId: number) => [
  `/api/v1/models/${modelId}/checks`
];

export type GetChecksApiV1ModelsModelIdChecksGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getChecksApiV1ModelsModelIdChecksGet>>
>;
export type GetChecksApiV1ModelsModelIdChecksGetQueryError = ErrorType<HTTPValidationError>;

export const useGetChecksApiV1ModelsModelIdChecksGet = <
  TData = Awaited<ReturnType<typeof getChecksApiV1ModelsModelIdChecksGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  modelId: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getChecksApiV1ModelsModelIdChecksGet>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetChecksApiV1ModelsModelIdChecksGetQueryKey(modelId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getChecksApiV1ModelsModelIdChecksGet>>> = ({ signal }) =>
    getChecksApiV1ModelsModelIdChecksGet(modelId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getChecksApiV1ModelsModelIdChecksGet>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!modelId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Delete check instance by identifier.
 * @summary Delete Check
 */
export const deleteCheckApiV1ModelsModelIdChecksCheckIdDelete = (modelId: number, checkId: number) =>
  customInstance<unknown>({ url: `/api/v1/models/${modelId}/checks/${checkId}`, method: 'delete' });

export type DeleteCheckApiV1ModelsModelIdChecksCheckIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteCheckApiV1ModelsModelIdChecksCheckIdDelete>>
>;

export type DeleteCheckApiV1ModelsModelIdChecksCheckIdDeleteMutationError = ErrorType<HTTPValidationError>;

export const useDeleteCheckApiV1ModelsModelIdChecksCheckIdDelete = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCheckApiV1ModelsModelIdChecksCheckIdDelete>>,
    TError,
    { modelId: number; checkId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteCheckApiV1ModelsModelIdChecksCheckIdDelete>>,
    { modelId: number; checkId: number }
  > = props => {
    const { modelId, checkId } = props ?? {};

    return deleteCheckApiV1ModelsModelIdChecksCheckIdDelete(modelId, checkId);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteCheckApiV1ModelsModelIdChecksCheckIdDelete>>,
    TError,
    { modelId: number; checkId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Run a check for each time window by start-end.

Parameters
----------
check_id : int
    ID of the check.
monitor_options : MonitorOptions
    The "monitor" options.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
CheckSchema
    Created check.
 * @summary Run Standalone Check Per Window In Range
 */
export const runStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPost = (
  checkId: number,
  monitorOptions: MonitorOptions
) =>
  customInstance<CheckResultSchema>({
    url: `/api/v1/checks/${checkId}/run/lookback`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: monitorOptions
  });

export type RunStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof runStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPost>>
>;
export type RunStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPostMutationBody = MonitorOptions;
export type RunStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPostMutationError =
  ErrorType<HTTPValidationError>;

export const useRunStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPost>>,
    TError,
    { checkId: number; data: MonitorOptions },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPost>>,
    { checkId: number; data: MonitorOptions }
  > = props => {
    const { checkId, data } = props ?? {};

    return runStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPost(checkId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPost>>,
    TError,
    { checkId: number; data: MonitorOptions },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Run a check for the time window.

Parameters
----------
check_id : int
    ID of the check.
monitor_options : MonitorOptions
    The window options.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
CheckSchema
    Created check.
 * @summary Get Check Window
 */
export const getCheckWindowApiV1ChecksCheckIdRunWindowPost = (checkId: number, monitorOptions: MonitorOptions) =>
  customInstance<unknown>({
    url: `/api/v1/checks/${checkId}/run/window`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: monitorOptions
  });

export type GetCheckWindowApiV1ChecksCheckIdRunWindowPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof getCheckWindowApiV1ChecksCheckIdRunWindowPost>>
>;
export type GetCheckWindowApiV1ChecksCheckIdRunWindowPostMutationBody = MonitorOptions;
export type GetCheckWindowApiV1ChecksCheckIdRunWindowPostMutationError = ErrorType<HTTPValidationError>;

export const useGetCheckWindowApiV1ChecksCheckIdRunWindowPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getCheckWindowApiV1ChecksCheckIdRunWindowPost>>,
    TError,
    { checkId: number; data: MonitorOptions },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getCheckWindowApiV1ChecksCheckIdRunWindowPost>>,
    { checkId: number; data: MonitorOptions }
  > = props => {
    const { checkId, data } = props ?? {};

    return getCheckWindowApiV1ChecksCheckIdRunWindowPost(checkId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof getCheckWindowApiV1ChecksCheckIdRunWindowPost>>,
    TError,
    { checkId: number; data: MonitorOptions },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Get the check configuration info and the possible values for the parameters.

Parameters
----------
check_id : int
    ID of the check.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
MonitorCheckConf
    the check configuration info and the possible values for the parameters.
 * @summary Get Check Info
 */
export const getCheckInfoApiV1ChecksCheckIdInfoGet = (checkId: number, signal?: AbortSignal) =>
  customInstance<MonitorCheckConf>({ url: `/api/v1/checks/${checkId}/info`, method: 'get', signal });

export const getGetCheckInfoApiV1ChecksCheckIdInfoGetQueryKey = (checkId: number) => [`/api/v1/checks/${checkId}/info`];

export type GetCheckInfoApiV1ChecksCheckIdInfoGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCheckInfoApiV1ChecksCheckIdInfoGet>>
>;
export type GetCheckInfoApiV1ChecksCheckIdInfoGetQueryError = ErrorType<HTTPValidationError>;

export const useGetCheckInfoApiV1ChecksCheckIdInfoGet = <
  TData = Awaited<ReturnType<typeof getCheckInfoApiV1ChecksCheckIdInfoGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  checkId: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getCheckInfoApiV1ChecksCheckIdInfoGet>>, TError, TData>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCheckInfoApiV1ChecksCheckIdInfoGetQueryKey(checkId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCheckInfoApiV1ChecksCheckIdInfoGet>>> = ({ signal }) =>
    getCheckInfoApiV1ChecksCheckIdInfoGet(checkId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getCheckInfoApiV1ChecksCheckIdInfoGet>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!checkId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Return all alert rules for the configuration screen.

Parameters
----------
models : list, optional
    The list of models to filter by.
severity : list, optional
    The list of severities to filter by.
sortby : list, optional
    The list of columns to sort by.
session : AsyncSession, optional
    The database connection.

Returns
-------
list
    The list of alert rules.
 * @summary Get All Alert Rules
 */
export const getAllAlertRulesApiV1ConfigAlertRulesGet = (
  params?: GetAllAlertRulesApiV1ConfigAlertRulesGetParams,
  signal?: AbortSignal
) => customInstance<AlertRuleConfigSchema[]>({ url: `/api/v1/config/alert-rules`, method: 'get', params, signal });

export const getGetAllAlertRulesApiV1ConfigAlertRulesGetQueryKey = (
  params?: GetAllAlertRulesApiV1ConfigAlertRulesGetParams
) => [`/api/v1/config/alert-rules`, ...(params ? [params] : [])];

export type GetAllAlertRulesApiV1ConfigAlertRulesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllAlertRulesApiV1ConfigAlertRulesGet>>
>;
export type GetAllAlertRulesApiV1ConfigAlertRulesGetQueryError = ErrorType<HTTPValidationError>;

export const useGetAllAlertRulesApiV1ConfigAlertRulesGet = <
  TData = Awaited<ReturnType<typeof getAllAlertRulesApiV1ConfigAlertRulesGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: GetAllAlertRulesApiV1ConfigAlertRulesGetParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getAllAlertRulesApiV1ConfigAlertRulesGet>>, TError, TData>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllAlertRulesApiV1ConfigAlertRulesGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllAlertRulesApiV1ConfigAlertRulesGet>>> = ({ signal }) =>
    getAllAlertRulesApiV1ConfigAlertRulesGet(params, signal);

  const query = useQuery<Awaited<ReturnType<typeof getAllAlertRulesApiV1ConfigAlertRulesGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Create a new monitor based on a check. This endpoint requires the name, lookback, data_filter and description of the monitor.
 * @summary Create a new monitor.
 */
export const createMonitorApiV1ChecksCheckIdMonitorsPost = (
  checkId: number,
  monitorCreationSchema: MonitorCreationSchema
) =>
  customInstance<IdResponse>({
    url: `/api/v1/checks/${checkId}/monitors`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: monitorCreationSchema
  });

export type CreateMonitorApiV1ChecksCheckIdMonitorsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createMonitorApiV1ChecksCheckIdMonitorsPost>>
>;
export type CreateMonitorApiV1ChecksCheckIdMonitorsPostMutationBody = MonitorCreationSchema;
export type CreateMonitorApiV1ChecksCheckIdMonitorsPostMutationError = ErrorType<HTTPValidationError>;

export const useCreateMonitorApiV1ChecksCheckIdMonitorsPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createMonitorApiV1ChecksCheckIdMonitorsPost>>,
    TError,
    { checkId: number; data: MonitorCreationSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createMonitorApiV1ChecksCheckIdMonitorsPost>>,
    { checkId: number; data: MonitorCreationSchema }
  > = props => {
    const { checkId, data } = props ?? {};

    return createMonitorApiV1ChecksCheckIdMonitorsPost(checkId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof createMonitorApiV1ChecksCheckIdMonitorsPost>>,
    TError,
    { checkId: number; data: MonitorCreationSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Get monitor by id.
 * @summary Get Monitor
 */
export const getMonitorApiV1MonitorsMonitorIdGet = (monitorId: number, signal?: AbortSignal) =>
  customInstance<MonitorSchema>({ url: `/api/v1/monitors/${monitorId}`, method: 'get', signal });

export const getGetMonitorApiV1MonitorsMonitorIdGetQueryKey = (monitorId: number) => [`/api/v1/monitors/${monitorId}`];

export type GetMonitorApiV1MonitorsMonitorIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMonitorApiV1MonitorsMonitorIdGet>>
>;
export type GetMonitorApiV1MonitorsMonitorIdGetQueryError = ErrorType<HTTPValidationError>;

export const useGetMonitorApiV1MonitorsMonitorIdGet = <
  TData = Awaited<ReturnType<typeof getMonitorApiV1MonitorsMonitorIdGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  monitorId: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getMonitorApiV1MonitorsMonitorIdGet>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMonitorApiV1MonitorsMonitorIdGetQueryKey(monitorId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonitorApiV1MonitorsMonitorIdGet>>> = ({ signal }) =>
    getMonitorApiV1MonitorsMonitorIdGet(monitorId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getMonitorApiV1MonitorsMonitorIdGet>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!monitorId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Update monitor by id.
 * @summary Update Monitor
 */
export const updateMonitorApiV1MonitorsMonitorIdPut = (monitorId: number, monitorUpdateSchema: MonitorUpdateSchema) =>
  customInstance<unknown>({
    url: `/api/v1/monitors/${monitorId}`,
    method: 'put',
    headers: { 'Content-Type': 'application/json' },
    data: monitorUpdateSchema
  });

export type UpdateMonitorApiV1MonitorsMonitorIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateMonitorApiV1MonitorsMonitorIdPut>>
>;
export type UpdateMonitorApiV1MonitorsMonitorIdPutMutationBody = MonitorUpdateSchema;
export type UpdateMonitorApiV1MonitorsMonitorIdPutMutationError = ErrorType<HTTPValidationError>;

export const useUpdateMonitorApiV1MonitorsMonitorIdPut = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMonitorApiV1MonitorsMonitorIdPut>>,
    TError,
    { monitorId: number; data: MonitorUpdateSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMonitorApiV1MonitorsMonitorIdPut>>,
    { monitorId: number; data: MonitorUpdateSchema }
  > = props => {
    const { monitorId, data } = props ?? {};

    return updateMonitorApiV1MonitorsMonitorIdPut(monitorId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof updateMonitorApiV1MonitorsMonitorIdPut>>,
    TError,
    { monitorId: number; data: MonitorUpdateSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Delete monitor by id.
 * @summary Delete Monitor
 */
export const deleteMonitorApiV1MonitorsMonitorIdDelete = (monitorId: number) =>
  customInstance<unknown>({ url: `/api/v1/monitors/${monitorId}`, method: 'delete' });

export type DeleteMonitorApiV1MonitorsMonitorIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteMonitorApiV1MonitorsMonitorIdDelete>>
>;

export type DeleteMonitorApiV1MonitorsMonitorIdDeleteMutationError = ErrorType<HTTPValidationError>;

export const useDeleteMonitorApiV1MonitorsMonitorIdDelete = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteMonitorApiV1MonitorsMonitorIdDelete>>,
    TError,
    { monitorId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteMonitorApiV1MonitorsMonitorIdDelete>>,
    { monitorId: number }
  > = props => {
    const { monitorId } = props ?? {};

    return deleteMonitorApiV1MonitorsMonitorIdDelete(monitorId);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteMonitorApiV1MonitorsMonitorIdDelete>>,
    TError,
    { monitorId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Run a monitor for each time window by lookback.

Parameters
----------
monitor_id : int
    ID of the monitor.
body
session : AsyncSession, optional
    SQLAlchemy session.
cache_funcs

Returns
-------
CheckSchema
    Created check.
 * @summary Run Monitor Lookback
 */
export const runMonitorLookbackApiV1MonitorsMonitorIdRunPost = (
  monitorId: number,
  monitorRunSchema: MonitorRunSchema
) =>
  customInstance<CheckResultSchema>({
    url: `/api/v1/monitors/${monitorId}/run`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: monitorRunSchema
  });

export type RunMonitorLookbackApiV1MonitorsMonitorIdRunPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof runMonitorLookbackApiV1MonitorsMonitorIdRunPost>>
>;
export type RunMonitorLookbackApiV1MonitorsMonitorIdRunPostMutationBody = MonitorRunSchema;
export type RunMonitorLookbackApiV1MonitorsMonitorIdRunPostMutationError = ErrorType<HTTPValidationError>;

export const useRunMonitorLookbackApiV1MonitorsMonitorIdRunPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runMonitorLookbackApiV1MonitorsMonitorIdRunPost>>,
    TError,
    { monitorId: number; data: MonitorRunSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runMonitorLookbackApiV1MonitorsMonitorIdRunPost>>,
    { monitorId: number; data: MonitorRunSchema }
  > = props => {
    const { monitorId, data } = props ?? {};

    return runMonitorLookbackApiV1MonitorsMonitorIdRunPost(monitorId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runMonitorLookbackApiV1MonitorsMonitorIdRunPost>>,
    TError,
    { monitorId: number; data: MonitorRunSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Get dashboard by if exists, if not then create it. Add top 5 unassigned monitors to the dashboard if empty.
 * @summary Get Dashboard
 */
export const getDashboardApiV1DashboardsGet = (signal?: AbortSignal) =>
  customInstance<DashboardSchema>({ url: `/api/v1/dashboards/`, method: 'get', signal });

export const getGetDashboardApiV1DashboardsGetQueryKey = () => [`/api/v1/dashboards/`];

export type GetDashboardApiV1DashboardsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDashboardApiV1DashboardsGet>>
>;
export type GetDashboardApiV1DashboardsGetQueryError = ErrorType<unknown>;

export const useGetDashboardApiV1DashboardsGet = <
  TData = Awaited<ReturnType<typeof getDashboardApiV1DashboardsGet>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getDashboardApiV1DashboardsGet>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDashboardApiV1DashboardsGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDashboardApiV1DashboardsGet>>> = ({ signal }) =>
    getDashboardApiV1DashboardsGet(signal);

  const query = useQuery<Awaited<ReturnType<typeof getDashboardApiV1DashboardsGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Update dashboard by id.
 * @summary Update Dashboard
 */
export const updateDashboardApiV1DashboardsDashboardIdPut = (
  dashboardId: number,
  dashboardUpdateSchema: DashboardUpdateSchema
) =>
  customInstance<unknown>({
    url: `/api/v1/dashboards/${dashboardId}`,
    method: 'put',
    headers: { 'Content-Type': 'application/json' },
    data: dashboardUpdateSchema
  });

export type UpdateDashboardApiV1DashboardsDashboardIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateDashboardApiV1DashboardsDashboardIdPut>>
>;
export type UpdateDashboardApiV1DashboardsDashboardIdPutMutationBody = DashboardUpdateSchema;
export type UpdateDashboardApiV1DashboardsDashboardIdPutMutationError = ErrorType<HTTPValidationError>;

export const useUpdateDashboardApiV1DashboardsDashboardIdPut = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDashboardApiV1DashboardsDashboardIdPut>>,
    TError,
    { dashboardId: number; data: DashboardUpdateSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDashboardApiV1DashboardsDashboardIdPut>>,
    { dashboardId: number; data: DashboardUpdateSchema }
  > = props => {
    const { dashboardId, data } = props ?? {};

    return updateDashboardApiV1DashboardsDashboardIdPut(dashboardId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof updateDashboardApiV1DashboardsDashboardIdPut>>,
    TError,
    { dashboardId: number; data: DashboardUpdateSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Delete dashboard by id.
 * @summary Delete Dashboard
 */
export const deleteDashboardApiV1DashboardsDashboardIdDelete = (dashboardId: number) =>
  customInstance<unknown>({ url: `/api/v1/dashboards/${dashboardId}`, method: 'delete' });

export type DeleteDashboardApiV1DashboardsDashboardIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteDashboardApiV1DashboardsDashboardIdDelete>>
>;

export type DeleteDashboardApiV1DashboardsDashboardIdDeleteMutationError = ErrorType<HTTPValidationError>;

export const useDeleteDashboardApiV1DashboardsDashboardIdDelete = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteDashboardApiV1DashboardsDashboardIdDelete>>,
    TError,
    { dashboardId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteDashboardApiV1DashboardsDashboardIdDelete>>,
    { dashboardId: number }
  > = props => {
    const { dashboardId } = props ?? {};

    return deleteDashboardApiV1DashboardsDashboardIdDelete(dashboardId);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteDashboardApiV1DashboardsDashboardIdDelete>>,
    TError,
    { dashboardId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * This API logs asynchronously a batch of new samples of the inference data of an existing model version, it requires the actual data and validates it matches the version schema.
 * @summary Log inference data per model version.
 */
export const logDataBatchApiV1ModelVersionsModelVersionIdDataPost = (
  modelVersionId: number,
  logDataBatchApiV1ModelVersionsModelVersionIdDataPostBodyItem: LogDataBatchApiV1ModelVersionsModelVersionIdDataPostBodyItem[]
) =>
  customInstance<unknown>({
    url: `/api/v1/model-versions/${modelVersionId}/data`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: logDataBatchApiV1ModelVersionsModelVersionIdDataPostBodyItem
  });

export type LogDataBatchApiV1ModelVersionsModelVersionIdDataPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof logDataBatchApiV1ModelVersionsModelVersionIdDataPost>>
>;
export type LogDataBatchApiV1ModelVersionsModelVersionIdDataPostMutationBody =
  LogDataBatchApiV1ModelVersionsModelVersionIdDataPostBodyItem[];
export type LogDataBatchApiV1ModelVersionsModelVersionIdDataPostMutationError = ErrorType<HTTPValidationError>;

export const useLogDataBatchApiV1ModelVersionsModelVersionIdDataPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logDataBatchApiV1ModelVersionsModelVersionIdDataPost>>,
    TError,
    { modelVersionId: number; data: LogDataBatchApiV1ModelVersionsModelVersionIdDataPostBodyItem[] },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof logDataBatchApiV1ModelVersionsModelVersionIdDataPost>>,
    { modelVersionId: number; data: LogDataBatchApiV1ModelVersionsModelVersionIdDataPostBodyItem[] }
  > = props => {
    const { modelVersionId, data } = props ?? {};

    return logDataBatchApiV1ModelVersionsModelVersionIdDataPost(modelVersionId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof logDataBatchApiV1ModelVersionsModelVersionIdDataPost>>,
    TError,
    { modelVersionId: number; data: LogDataBatchApiV1ModelVersionsModelVersionIdDataPostBodyItem[] },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Update data samples.

Parameters
----------
request
model_version_id
data
session
data_ingest
 * @summary Update Data Batch
 */
export const updateDataBatchApiV1ModelVersionsModelVersionIdDataPut = (
  modelVersionId: number,
  updateDataBatchApiV1ModelVersionsModelVersionIdDataPutBodyItem: UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutBodyItem[]
) =>
  customInstance<unknown>({
    url: `/api/v1/model-versions/${modelVersionId}/data`,
    method: 'put',
    headers: { 'Content-Type': 'application/json' },
    data: updateDataBatchApiV1ModelVersionsModelVersionIdDataPutBodyItem
  });

export type UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateDataBatchApiV1ModelVersionsModelVersionIdDataPut>>
>;
export type UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutMutationBody =
  UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutBodyItem[];
export type UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutMutationError = ErrorType<HTTPValidationError>;

export const useUpdateDataBatchApiV1ModelVersionsModelVersionIdDataPut = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDataBatchApiV1ModelVersionsModelVersionIdDataPut>>,
    TError,
    { modelVersionId: number; data: UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutBodyItem[] },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDataBatchApiV1ModelVersionsModelVersionIdDataPut>>,
    { modelVersionId: number; data: UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutBodyItem[] }
  > = props => {
    const { modelVersionId, data } = props ?? {};

    return updateDataBatchApiV1ModelVersionsModelVersionIdDataPut(modelVersionId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof updateDataBatchApiV1ModelVersionsModelVersionIdDataPut>>,
    TError,
    { modelVersionId: number; data: UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutBodyItem[] },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * This API uploads asynchronously a reference data file for a given model version,it requires the actual data and validates it matches the version schema.
 * @summary Upload reference data for a given model version.
 */
export const saveReferenceApiV1ModelVersionsModelVersionIdReferencePost = (
  modelVersionId: number,
  bodySaveReferenceApiV1ModelVersionsModelVersionIdReferencePost: BodySaveReferenceApiV1ModelVersionsModelVersionIdReferencePost
) => {
  const formData = new FormData();
  formData.append('file', bodySaveReferenceApiV1ModelVersionsModelVersionIdReferencePost.file);

  return customInstance<unknown>({
    url: `/api/v1/model-versions/${modelVersionId}/reference`,
    method: 'post',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData
  });
};

export type SaveReferenceApiV1ModelVersionsModelVersionIdReferencePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof saveReferenceApiV1ModelVersionsModelVersionIdReferencePost>>
>;
export type SaveReferenceApiV1ModelVersionsModelVersionIdReferencePostMutationBody =
  BodySaveReferenceApiV1ModelVersionsModelVersionIdReferencePost;
export type SaveReferenceApiV1ModelVersionsModelVersionIdReferencePostMutationError = ErrorType<HTTPValidationError>;

export const useSaveReferenceApiV1ModelVersionsModelVersionIdReferencePost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveReferenceApiV1ModelVersionsModelVersionIdReferencePost>>,
    TError,
    { modelVersionId: number; data: BodySaveReferenceApiV1ModelVersionsModelVersionIdReferencePost },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveReferenceApiV1ModelVersionsModelVersionIdReferencePost>>,
    { modelVersionId: number; data: BodySaveReferenceApiV1ModelVersionsModelVersionIdReferencePost }
  > = props => {
    const { modelVersionId, data } = props ?? {};

    return saveReferenceApiV1ModelVersionsModelVersionIdReferencePost(modelVersionId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof saveReferenceApiV1ModelVersionsModelVersionIdReferencePost>>,
    TError,
    { modelVersionId: number; data: BodySaveReferenceApiV1ModelVersionsModelVersionIdReferencePost },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Create a new model with its name, task type, and description. Returns the ID of the model.
 * @summary Create a new model.
 */
export const getCreateModelApiV1ModelsPost = (modelCreationSchema: ModelCreationSchema) =>
  customInstance<IdResponse>({
    url: `/api/v1/models`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: modelCreationSchema
  });

export type GetCreateModelApiV1ModelsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof getCreateModelApiV1ModelsPost>>
>;
export type GetCreateModelApiV1ModelsPostMutationBody = ModelCreationSchema;
export type GetCreateModelApiV1ModelsPostMutationError = ErrorType<HTTPValidationError>;

export const useGetCreateModelApiV1ModelsPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getCreateModelApiV1ModelsPost>>,
    TError,
    { data: ModelCreationSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getCreateModelApiV1ModelsPost>>,
    { data: ModelCreationSchema }
  > = props => {
    const { data } = props ?? {};

    return getCreateModelApiV1ModelsPost(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof getCreateModelApiV1ModelsPost>>,
    TError,
    { data: ModelCreationSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Retrieve models data ingestion status.
 * @summary Retrieve Models Data Ingestion
 */
export const retrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGet = (
  modelId: number,
  params?: RetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGetParams,
  signal?: AbortSignal
) =>
  customInstance<ModelDailyIngestion[]>({
    url: `/api/v1/models/${modelId}/data-ingestion`,
    method: 'get',
    params,
    signal
  });

export const getRetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGetQueryKey = (
  modelId: number,
  params?: RetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGetParams
) => [`/api/v1/models/${modelId}/data-ingestion`, ...(params ? [params] : [])];

export type RetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGet>>
>;
export type RetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGetQueryError = ErrorType<HTTPValidationError>;

export const useRetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGet = <
  TData = Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  modelId: number,
  params?: RetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGetParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGet>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGetQueryKey(modelId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGet>>
  > = ({ signal }) => retrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGet(modelId, params, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGet>>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!modelId, ...queryOptions }) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * Retrieve models data ingestion status.
 * @summary Retrieve Models Data Ingestion
 */
export const retrieveModelsDataIngestionApiV1ModelsDataIngestionGet = (
  params?: RetrieveModelsDataIngestionApiV1ModelsDataIngestionGetParams,
  signal?: AbortSignal
) =>
  customInstance<RetrieveModelsDataIngestionApiV1ModelsDataIngestionGet200>({
    url: `/api/v1/models/data-ingestion`,
    method: 'get',
    params,
    signal
  });

export const getRetrieveModelsDataIngestionApiV1ModelsDataIngestionGetQueryKey = (
  params?: RetrieveModelsDataIngestionApiV1ModelsDataIngestionGetParams
) => [`/api/v1/models/data-ingestion`, ...(params ? [params] : [])];

export type RetrieveModelsDataIngestionApiV1ModelsDataIngestionGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsDataIngestionGet>>
>;
export type RetrieveModelsDataIngestionApiV1ModelsDataIngestionGetQueryError = ErrorType<HTTPValidationError>;

export const useRetrieveModelsDataIngestionApiV1ModelsDataIngestionGet = <
  TData = Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsDataIngestionGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: RetrieveModelsDataIngestionApiV1ModelsDataIngestionGetParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsDataIngestionGet>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRetrieveModelsDataIngestionApiV1ModelsDataIngestionGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsDataIngestionGet>>> = ({
    signal
  }) => retrieveModelsDataIngestionApiV1ModelsDataIngestionGet(params, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsDataIngestionGet>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Create a new model.

Parameters
----------
model_id : int
    Model to return.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
ModelSchema
    Created model.
 * @summary Get Model
 */
export const getModelApiV1ModelsModelIdGet = (modelId: number, signal?: AbortSignal) =>
  customInstance<ModelSchema>({ url: `/api/v1/models/${modelId}`, method: 'get', signal });

export const getGetModelApiV1ModelsModelIdGetQueryKey = (modelId: number) => [`/api/v1/models/${modelId}`];

export type GetModelApiV1ModelsModelIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getModelApiV1ModelsModelIdGet>>
>;
export type GetModelApiV1ModelsModelIdGetQueryError = ErrorType<HTTPValidationError>;

export const useGetModelApiV1ModelsModelIdGet = <
  TData = Awaited<ReturnType<typeof getModelApiV1ModelsModelIdGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  modelId: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getModelApiV1ModelsModelIdGet>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetModelApiV1ModelsModelIdGetQueryKey(modelId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getModelApiV1ModelsModelIdGet>>> = ({ signal }) =>
    getModelApiV1ModelsModelIdGet(modelId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getModelApiV1ModelsModelIdGet>>, TError, TData>(queryKey, queryFn, {
    enabled: !!modelId,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Create a new model.

Parameters
----------
model_id : int
    Model to return.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
NameIdResponse
    Created model.
 * @summary Get Versions Per Model
 */
export const getVersionsPerModelApiV1ModelsModelIdVersionsGet = (modelId: number, signal?: AbortSignal) =>
  customInstance<NameIdResponse[]>({ url: `/api/v1/models/${modelId}/versions`, method: 'get', signal });

export const getGetVersionsPerModelApiV1ModelsModelIdVersionsGetQueryKey = (modelId: number) => [
  `/api/v1/models/${modelId}/versions`
];

export type GetVersionsPerModelApiV1ModelsModelIdVersionsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVersionsPerModelApiV1ModelsModelIdVersionsGet>>
>;
export type GetVersionsPerModelApiV1ModelsModelIdVersionsGetQueryError = ErrorType<HTTPValidationError>;

export const useGetVersionsPerModelApiV1ModelsModelIdVersionsGet = <
  TData = Awaited<ReturnType<typeof getVersionsPerModelApiV1ModelsModelIdVersionsGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  modelId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getVersionsPerModelApiV1ModelsModelIdVersionsGet>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVersionsPerModelApiV1ModelsModelIdVersionsGetQueryKey(modelId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVersionsPerModelApiV1ModelsModelIdVersionsGet>>> = ({
    signal
  }) => getVersionsPerModelApiV1ModelsModelIdVersionsGet(modelId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getVersionsPerModelApiV1ModelsModelIdVersionsGet>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!modelId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Create a new model.

Parameters
----------
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
List[ModelsInfoSchema]
    List of models.
 * @summary Get Models
 */
export const getModelsApiV1ModelsGet = (signal?: AbortSignal) =>
  customInstance<ModelsInfoSchema[]>({ url: `/api/v1/models/`, method: 'get', signal });

export const getGetModelsApiV1ModelsGetQueryKey = () => [`/api/v1/models/`];

export type GetModelsApiV1ModelsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getModelsApiV1ModelsGet>>>;
export type GetModelsApiV1ModelsGetQueryError = ErrorType<unknown>;

export const useGetModelsApiV1ModelsGet = <
  TData = Awaited<ReturnType<typeof getModelsApiV1ModelsGet>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getModelsApiV1ModelsGet>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetModelsApiV1ModelsGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getModelsApiV1ModelsGet>>> = ({ signal }) =>
    getModelsApiV1ModelsGet(signal);

  const query = useQuery<Awaited<ReturnType<typeof getModelsApiV1ModelsGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Get statistics of columns for model.

Parameters
----------
model_id : int
    Model get columns for.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
Dict[str, ColumnMetadata]
    Column name and metadata (type and value if available).
 * @summary Get Model Columns
 */
export const getModelColumnsApiV1ModelsModelIdColumnsGet = (modelId: number, signal?: AbortSignal) =>
  customInstance<GetModelColumnsApiV1ModelsModelIdColumnsGet200>({
    url: `/api/v1/models/${modelId}/columns`,
    method: 'get',
    signal
  });

export const getGetModelColumnsApiV1ModelsModelIdColumnsGetQueryKey = (modelId: number) => [
  `/api/v1/models/${modelId}/columns`
];

export type GetModelColumnsApiV1ModelsModelIdColumnsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getModelColumnsApiV1ModelsModelIdColumnsGet>>
>;
export type GetModelColumnsApiV1ModelsModelIdColumnsGetQueryError = ErrorType<HTTPValidationError>;

export const useGetModelColumnsApiV1ModelsModelIdColumnsGet = <
  TData = Awaited<ReturnType<typeof getModelColumnsApiV1ModelsModelIdColumnsGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  modelId: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getModelColumnsApiV1ModelsModelIdColumnsGet>>, TError, TData>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetModelColumnsApiV1ModelsModelIdColumnsGetQueryKey(modelId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getModelColumnsApiV1ModelsModelIdColumnsGet>>> = ({
    signal
  }) => getModelColumnsApiV1ModelsModelIdColumnsGet(modelId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getModelColumnsApiV1ModelsModelIdColumnsGet>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!modelId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Create a new model version.

Parameters
----------
request
model_id : int
    ID of the model.
info : VersionInfo
    Information about the model version.
session : AsyncSession, optional
    SQLAlchemy session.
kafka_admin
settings
data_ingest
cache_invalidator
 * @summary Get Or Create Version
 */
export const getOrCreateVersionApiV1ModelsModelIdVersionPost = (
  modelId: number,
  modelVersionCreationSchema: ModelVersionCreationSchema
) =>
  customInstance<IdResponse>({
    url: `/api/v1/models/${modelId}/version`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: modelVersionCreationSchema
  });

export type GetOrCreateVersionApiV1ModelsModelIdVersionPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof getOrCreateVersionApiV1ModelsModelIdVersionPost>>
>;
export type GetOrCreateVersionApiV1ModelsModelIdVersionPostMutationBody = ModelVersionCreationSchema;
export type GetOrCreateVersionApiV1ModelsModelIdVersionPostMutationError = ErrorType<HTTPValidationError>;

export const useGetOrCreateVersionApiV1ModelsModelIdVersionPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getOrCreateVersionApiV1ModelsModelIdVersionPost>>,
    TError,
    { modelId: number; data: ModelVersionCreationSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getOrCreateVersionApiV1ModelsModelIdVersionPost>>,
    { modelId: number; data: ModelVersionCreationSchema }
  > = props => {
    const { modelId, data } = props ?? {};

    return getOrCreateVersionApiV1ModelsModelIdVersionPost(modelId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof getOrCreateVersionApiV1ModelsModelIdVersionPost>>,
    TError,
    { modelId: number; data: ModelVersionCreationSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Return json schema of the model version data to use in validation on client-side.

Parameters
----------
model_version_id
session

Returns
-------
json schema of the model version
 * @summary Get Schema
 */
export const getSchemaApiV1ModelVersionsModelVersionIdSchemaGet = (modelVersionId: number, signal?: AbortSignal) =>
  customInstance<unknown>({ url: `/api/v1/model-versions/${modelVersionId}/schema`, method: 'get', signal });

export const getGetSchemaApiV1ModelVersionsModelVersionIdSchemaGetQueryKey = (modelVersionId: number) => [
  `/api/v1/model-versions/${modelVersionId}/schema`
];

export type GetSchemaApiV1ModelVersionsModelVersionIdSchemaGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSchemaApiV1ModelVersionsModelVersionIdSchemaGet>>
>;
export type GetSchemaApiV1ModelVersionsModelVersionIdSchemaGetQueryError = ErrorType<HTTPValidationError>;

export const useGetSchemaApiV1ModelVersionsModelVersionIdSchemaGet = <
  TData = Awaited<ReturnType<typeof getSchemaApiV1ModelVersionsModelVersionIdSchemaGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  modelVersionId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getSchemaApiV1ModelVersionsModelVersionIdSchemaGet>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSchemaApiV1ModelVersionsModelVersionIdSchemaGetQueryKey(modelVersionId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSchemaApiV1ModelVersionsModelVersionIdSchemaGet>>> = ({
    signal
  }) => getSchemaApiV1ModelVersionsModelVersionIdSchemaGet(modelVersionId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getSchemaApiV1ModelVersionsModelVersionIdSchemaGet>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!modelVersionId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Return json schema of the model version data to use in validation on client-side.

Parameters
----------
model_version_id
session

Returns
-------
json schema of the model version
 * @summary Get Reference Schema
 */
export const getReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGet = (
  modelVersionId: number,
  signal?: AbortSignal
) =>
  customInstance<unknown>({ url: `/api/v1/model-versions/${modelVersionId}/reference-schema`, method: 'get', signal });

export const getGetReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGetQueryKey = (
  modelVersionId: number
) => [`/api/v1/model-versions/${modelVersionId}/reference-schema`];

export type GetReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGet>>
>;
export type GetReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGetQueryError =
  ErrorType<HTTPValidationError>;

export const useGetReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGet = <
  TData = Awaited<ReturnType<typeof getReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  modelVersionId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGet>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGetQueryKey(modelVersionId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGet>>
  > = ({ signal }) => getReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGet(modelVersionId, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof getReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGet>>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!modelVersionId, ...queryOptions }) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * Run suite (all checks defined) on given model version.

Parameters
----------
model_version_id
monitor_options
session

Returns
-------
HTML of the suite result.
 * @summary Run Suite On Model Version
 */
export const runSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPost = (
  modelVersionId: number,
  monitorOptions: MonitorOptions
) =>
  customInstance<string>({
    url: `/api/v1/model-versions/${modelVersionId}/suite-run`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: monitorOptions
  });

export type RunSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof runSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPost>>
>;
export type RunSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPostMutationBody = MonitorOptions;
export type RunSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPostMutationError =
  ErrorType<HTTPValidationError>;

export const useRunSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPost>>,
    TError,
    { modelVersionId: number; data: MonitorOptions },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPost>>,
    { modelVersionId: number; data: MonitorOptions }
  > = props => {
    const { modelVersionId, data } = props ?? {};

    return runSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPost(modelVersionId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPost>>,
    TError,
    { modelVersionId: number; data: MonitorOptions },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Return json schema of the model version data to use in validation on client-side.

Parameters
----------
model_version_id
session

Returns
-------
json schema of the model version
 * @summary Get Count Samples
 */
export const getCountSamplesApiV1ModelVersionsModelVersionIdCountSamplesGet = (
  modelVersionId: number,
  signal?: AbortSignal
) => customInstance<unknown>({ url: `/api/v1/model-versions/${modelVersionId}/count-samples`, method: 'get', signal });

export const getGetCountSamplesApiV1ModelVersionsModelVersionIdCountSamplesGetQueryKey = (modelVersionId: number) => [
  `/api/v1/model-versions/${modelVersionId}/count-samples`
];

export type GetCountSamplesApiV1ModelVersionsModelVersionIdCountSamplesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCountSamplesApiV1ModelVersionsModelVersionIdCountSamplesGet>>
>;
export type GetCountSamplesApiV1ModelVersionsModelVersionIdCountSamplesGetQueryError = ErrorType<HTTPValidationError>;

export const useGetCountSamplesApiV1ModelVersionsModelVersionIdCountSamplesGet = <
  TData = Awaited<ReturnType<typeof getCountSamplesApiV1ModelVersionsModelVersionIdCountSamplesGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  modelVersionId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getCountSamplesApiV1ModelVersionsModelVersionIdCountSamplesGet>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetCountSamplesApiV1ModelVersionsModelVersionIdCountSamplesGetQueryKey(modelVersionId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCountSamplesApiV1ModelVersionsModelVersionIdCountSamplesGet>>
  > = ({ signal }) => getCountSamplesApiV1ModelVersionsModelVersionIdCountSamplesGet(modelVersionId, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof getCountSamplesApiV1ModelVersionsModelVersionIdCountSamplesGet>>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!modelVersionId, ...queryOptions }) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * Delete model version by id.
 * @summary Delete Model Version
 */
export const deleteModelVersionApiV1ModelVersionsModelVersionIdDelete = (modelVersionId: number) =>
  customInstance<unknown>({ url: `/api/v1/model-versions/${modelVersionId}`, method: 'delete' });

export type DeleteModelVersionApiV1ModelVersionsModelVersionIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteModelVersionApiV1ModelVersionsModelVersionIdDelete>>
>;

export type DeleteModelVersionApiV1ModelVersionsModelVersionIdDeleteMutationError = ErrorType<HTTPValidationError>;

export const useDeleteModelVersionApiV1ModelVersionsModelVersionIdDelete = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteModelVersionApiV1ModelVersionsModelVersionIdDelete>>,
    TError,
    { modelVersionId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteModelVersionApiV1ModelVersionsModelVersionIdDelete>>,
    { modelVersionId: number }
  > = props => {
    const { modelVersionId } = props ?? {};

    return deleteModelVersionApiV1ModelVersionsModelVersionIdDelete(modelVersionId);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteModelVersionApiV1ModelVersionsModelVersionIdDelete>>,
    TError,
    { modelVersionId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Redirect to the Auth0 login page.
 * @summary Auth0 Login
 */
export const auth0LoginApiV1AuthLoginAuth0Get = (signal?: AbortSignal) =>
  customInstance<unknown>({ url: `/api/v1/auth/login/auth0`, method: 'get', signal });

export const getAuth0LoginApiV1AuthLoginAuth0GetQueryKey = () => [`/api/v1/auth/login/auth0`];

export type Auth0LoginApiV1AuthLoginAuth0GetQueryResult = NonNullable<
  Awaited<ReturnType<typeof auth0LoginApiV1AuthLoginAuth0Get>>
>;
export type Auth0LoginApiV1AuthLoginAuth0GetQueryError = ErrorType<unknown>;

export const useAuth0LoginApiV1AuthLoginAuth0Get = <
  TData = Awaited<ReturnType<typeof auth0LoginApiV1AuthLoginAuth0Get>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof auth0LoginApiV1AuthLoginAuth0Get>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuth0LoginApiV1AuthLoginAuth0GetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof auth0LoginApiV1AuthLoginAuth0Get>>> = ({ signal }) =>
    auth0LoginApiV1AuthLoginAuth0Get(signal);

  const query = useQuery<Awaited<ReturnType<typeof auth0LoginApiV1AuthLoginAuth0Get>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Get the user details from the Auth0 callback.
 * @summary Auth0 Callback
 */
export const auth0CallbackApiV1AuthLoginAuth0CallbackGet = (signal?: AbortSignal) =>
  customInstance<unknown>({ url: `/api/v1/auth/login/auth0/callback`, method: 'get', signal });

export const getAuth0CallbackApiV1AuthLoginAuth0CallbackGetQueryKey = () => [`/api/v1/auth/login/auth0/callback`];

export type Auth0CallbackApiV1AuthLoginAuth0CallbackGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof auth0CallbackApiV1AuthLoginAuth0CallbackGet>>
>;
export type Auth0CallbackApiV1AuthLoginAuth0CallbackGetQueryError = ErrorType<unknown>;

export const useAuth0CallbackApiV1AuthLoginAuth0CallbackGet = <
  TData = Awaited<ReturnType<typeof auth0CallbackApiV1AuthLoginAuth0CallbackGet>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof auth0CallbackApiV1AuthLoginAuth0CallbackGet>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuth0CallbackApiV1AuthLoginAuth0CallbackGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof auth0CallbackApiV1AuthLoginAuth0CallbackGet>>> = ({
    signal
  }) => auth0CallbackApiV1AuthLoginAuth0CallbackGet(signal);

  const query = useQuery<Awaited<ReturnType<typeof auth0CallbackApiV1AuthLoginAuth0CallbackGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Create invite between organization and a user
 * @summary Create Invite
 */
export const createInviteApiV1OrganizationInvitePut = (invitationCreationSchema: InvitationCreationSchema) =>
  customInstance<unknown>({
    url: `/api/v1/organization/invite`,
    method: 'put',
    headers: { 'Content-Type': 'application/json' },
    data: invitationCreationSchema
  });

export type CreateInviteApiV1OrganizationInvitePutMutationResult = NonNullable<
  Awaited<ReturnType<typeof createInviteApiV1OrganizationInvitePut>>
>;
export type CreateInviteApiV1OrganizationInvitePutMutationBody = InvitationCreationSchema;
export type CreateInviteApiV1OrganizationInvitePutMutationError = ErrorType<HTTPValidationError>;

export const useCreateInviteApiV1OrganizationInvitePut = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createInviteApiV1OrganizationInvitePut>>,
    TError,
    { data: InvitationCreationSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createInviteApiV1OrganizationInvitePut>>,
    { data: InvitationCreationSchema }
  > = props => {
    const { data } = props ?? {};

    return createInviteApiV1OrganizationInvitePut(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof createInviteApiV1OrganizationInvitePut>>,
    TError,
    { data: InvitationCreationSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * @summary Retrive Organization
 */
export const retriveOrganizationApiV1OrganizationGet = (signal?: AbortSignal) =>
  customInstance<unknown>({ url: `/api/v1/organization`, method: 'get', signal });

export const getRetriveOrganizationApiV1OrganizationGetQueryKey = () => [`/api/v1/organization`];

export type RetriveOrganizationApiV1OrganizationGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof retriveOrganizationApiV1OrganizationGet>>
>;
export type RetriveOrganizationApiV1OrganizationGetQueryError = ErrorType<unknown>;

export const useRetriveOrganizationApiV1OrganizationGet = <
  TData = Awaited<ReturnType<typeof retriveOrganizationApiV1OrganizationGet>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof retriveOrganizationApiV1OrganizationGet>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRetriveOrganizationApiV1OrganizationGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof retriveOrganizationApiV1OrganizationGet>>> = ({ signal }) =>
    retriveOrganizationApiV1OrganizationGet(signal);

  const query = useQuery<Awaited<ReturnType<typeof retriveOrganizationApiV1OrganizationGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Update Organization
 */
export const updateOrganizationApiV1OrganizationPut = (organizationUpdateSchema: OrganizationUpdateSchema) =>
  customInstance<unknown>({
    url: `/api/v1/organization`,
    method: 'put',
    headers: { 'Content-Type': 'application/json' },
    data: organizationUpdateSchema
  });

export type UpdateOrganizationApiV1OrganizationPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateOrganizationApiV1OrganizationPut>>
>;
export type UpdateOrganizationApiV1OrganizationPutMutationBody = OrganizationUpdateSchema;
export type UpdateOrganizationApiV1OrganizationPutMutationError = ErrorType<HTTPValidationError>;

export const useUpdateOrganizationApiV1OrganizationPut = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateOrganizationApiV1OrganizationPut>>,
    TError,
    { data: OrganizationUpdateSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateOrganizationApiV1OrganizationPut>>,
    { data: OrganizationUpdateSchema }
  > = props => {
    const { data } = props ?? {};

    return updateOrganizationApiV1OrganizationPut(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof updateOrganizationApiV1OrganizationPut>>,
    TError,
    { data: OrganizationUpdateSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Retrive organization members
 * @summary Retrive Organization Members
 */
export const retriveOrganizationMembersApiV1OrganizationMembersGet = (signal?: AbortSignal) =>
  customInstance<MemberSchema[]>({ url: `/api/v1/organization/members`, method: 'get', signal });

export const getRetriveOrganizationMembersApiV1OrganizationMembersGetQueryKey = () => [`/api/v1/organization/members`];

export type RetriveOrganizationMembersApiV1OrganizationMembersGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof retriveOrganizationMembersApiV1OrganizationMembersGet>>
>;
export type RetriveOrganizationMembersApiV1OrganizationMembersGetQueryError = ErrorType<unknown>;

export const useRetriveOrganizationMembersApiV1OrganizationMembersGet = <
  TData = Awaited<ReturnType<typeof retriveOrganizationMembersApiV1OrganizationMembersGet>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof retriveOrganizationMembersApiV1OrganizationMembersGet>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRetriveOrganizationMembersApiV1OrganizationMembersGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof retriveOrganizationMembersApiV1OrganizationMembersGet>>> = ({
    signal
  }) => retriveOrganizationMembersApiV1OrganizationMembersGet(signal);

  const query = useQuery<
    Awaited<ReturnType<typeof retriveOrganizationMembersApiV1OrganizationMembersGet>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Remove member from an organization
 * @summary Remove Organization Member
 */
export const removeOrganizationMemberApiV1OrganizationMembersMemberIdDelete = (memberId: number) =>
  customInstance<unknown>({ url: `/api/v1/organization/members/${memberId}`, method: 'delete' });

export type RemoveOrganizationMemberApiV1OrganizationMembersMemberIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeOrganizationMemberApiV1OrganizationMembersMemberIdDelete>>
>;

export type RemoveOrganizationMemberApiV1OrganizationMembersMemberIdDeleteMutationError =
  ErrorType<HTTPValidationError>;

export const useRemoveOrganizationMemberApiV1OrganizationMembersMemberIdDelete = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeOrganizationMemberApiV1OrganizationMembersMemberIdDelete>>,
    TError,
    { memberId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeOrganizationMemberApiV1OrganizationMembersMemberIdDelete>>,
    { memberId: number }
  > = props => {
    const { memberId } = props ?? {};

    return removeOrganizationMemberApiV1OrganizationMembersMemberIdDelete(memberId);
  };

  return useMutation<
    Awaited<ReturnType<typeof removeOrganizationMemberApiV1OrganizationMembersMemberIdDelete>>,
    TError,
    { memberId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Get info needed for the complete details page.
 * @summary Get Complete Details
 */
export const getCompleteDetailsApiV1UsersCompleteDetailsGet = (signal?: AbortSignal) =>
  customInstance<CompleteDetailsSchema>({ url: `/api/v1/users/complete-details`, method: 'get', signal });

export const getGetCompleteDetailsApiV1UsersCompleteDetailsGetQueryKey = () => [`/api/v1/users/complete-details`];

export type GetCompleteDetailsApiV1UsersCompleteDetailsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCompleteDetailsApiV1UsersCompleteDetailsGet>>
>;
export type GetCompleteDetailsApiV1UsersCompleteDetailsGetQueryError = ErrorType<unknown>;

export const useGetCompleteDetailsApiV1UsersCompleteDetailsGet = <
  TData = Awaited<ReturnType<typeof getCompleteDetailsApiV1UsersCompleteDetailsGet>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getCompleteDetailsApiV1UsersCompleteDetailsGet>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCompleteDetailsApiV1UsersCompleteDetailsGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCompleteDetailsApiV1UsersCompleteDetailsGet>>> = ({
    signal
  }) => getCompleteDetailsApiV1UsersCompleteDetailsGet(signal);

  const query = useQuery<Awaited<ReturnType<typeof getCompleteDetailsApiV1UsersCompleteDetailsGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Complete user details for final login.
 * @summary Update Complete Details
 */
export const updateCompleteDetailsApiV1UsersCompleteDetailsPost = (
  completeDetailsUpdateSchema: CompleteDetailsUpdateSchema
) =>
  customInstance<unknown>({
    url: `/api/v1/users/complete-details`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: completeDetailsUpdateSchema
  });

export type UpdateCompleteDetailsApiV1UsersCompleteDetailsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateCompleteDetailsApiV1UsersCompleteDetailsPost>>
>;
export type UpdateCompleteDetailsApiV1UsersCompleteDetailsPostMutationBody = CompleteDetailsUpdateSchema;
export type UpdateCompleteDetailsApiV1UsersCompleteDetailsPostMutationError = ErrorType<HTTPValidationError>;

export const useUpdateCompleteDetailsApiV1UsersCompleteDetailsPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCompleteDetailsApiV1UsersCompleteDetailsPost>>,
    TError,
    { data: CompleteDetailsUpdateSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCompleteDetailsApiV1UsersCompleteDetailsPost>>,
    { data: CompleteDetailsUpdateSchema }
  > = props => {
    const { data } = props ?? {};

    return updateCompleteDetailsApiV1UsersCompleteDetailsPost(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof updateCompleteDetailsApiV1UsersCompleteDetailsPost>>,
    TError,
    { data: CompleteDetailsUpdateSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * @summary Leave Organization
 */
export const leaveOrganizationApiV1UsersLeaveOrganizationPost = () =>
  customInstance<unknown>({ url: `/api/v1/users/leave-organization`, method: 'post' });

export type LeaveOrganizationApiV1UsersLeaveOrganizationPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof leaveOrganizationApiV1UsersLeaveOrganizationPost>>
>;

export type LeaveOrganizationApiV1UsersLeaveOrganizationPostMutationError = ErrorType<unknown>;

export const useLeaveOrganizationApiV1UsersLeaveOrganizationPost = <
  TError = ErrorType<unknown>,
  TVariables = void,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof leaveOrganizationApiV1UsersLeaveOrganizationPost>>,
    TError,
    TVariables,
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof leaveOrganizationApiV1UsersLeaveOrganizationPost>>,
    TVariables
  > = () => leaveOrganizationApiV1UsersLeaveOrganizationPost();

  return useMutation<
    Awaited<ReturnType<typeof leaveOrganizationApiV1UsersLeaveOrganizationPost>>,
    TError,
    TVariables,
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Retrieve user details
 * @summary Retrieve User Info
 */
export const retrieveUserInfoApiV1UsersMeGet = (signal?: AbortSignal) =>
  customInstance<UserSchema>({ url: `/api/v1/users/me`, method: 'get', signal });

export const getRetrieveUserInfoApiV1UsersMeGetQueryKey = () => [`/api/v1/users/me`];

export type RetrieveUserInfoApiV1UsersMeGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof retrieveUserInfoApiV1UsersMeGet>>
>;
export type RetrieveUserInfoApiV1UsersMeGetQueryError = ErrorType<unknown>;

export const useRetrieveUserInfoApiV1UsersMeGet = <
  TData = Awaited<ReturnType<typeof retrieveUserInfoApiV1UsersMeGet>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof retrieveUserInfoApiV1UsersMeGet>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRetrieveUserInfoApiV1UsersMeGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveUserInfoApiV1UsersMeGet>>> = ({ signal }) =>
    retrieveUserInfoApiV1UsersMeGet(signal);

  const query = useQuery<Awaited<ReturnType<typeof retrieveUserInfoApiV1UsersMeGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Redirect user to the slack authorization page.

codeflow:
1. Authentificate user
2. Verify whether user has permissins to do operation
3. Issue 'installation state' to prevent forgery attack
4. Generate redirection URL
5. Set 'installation state' cookie
6. Redirect user to slack authorization page.

NOTE:
current implementation is not complete,
currently we do not have authorization subsystem (point 2)

Slack authorization URL description:
https://slack.com/oauth/v2/authorize?state=&client_id=&scope=&user_scope=
state - installation state, slack will include it in request with exchange code
client_id - application client id
scope - list of bot permissions
user_scope -
 * @summary Slack-Authorization-Redirect
 */
export const slackAuthorizationRedirectApiV1SlackAuthorizeGet = (signal?: AbortSignal) =>
  customInstance<unknown>({ url: `/api/v1/slack.authorize`, method: 'get', signal });

export const getSlackAuthorizationRedirectApiV1SlackAuthorizeGetQueryKey = () => [`/api/v1/slack.authorize`];

export type SlackAuthorizationRedirectApiV1SlackAuthorizeGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof slackAuthorizationRedirectApiV1SlackAuthorizeGet>>
>;
export type SlackAuthorizationRedirectApiV1SlackAuthorizeGetQueryError = ErrorType<unknown>;

export const useSlackAuthorizationRedirectApiV1SlackAuthorizeGet = <
  TData = Awaited<ReturnType<typeof slackAuthorizationRedirectApiV1SlackAuthorizeGet>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof slackAuthorizationRedirectApiV1SlackAuthorizeGet>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSlackAuthorizationRedirectApiV1SlackAuthorizeGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof slackAuthorizationRedirectApiV1SlackAuthorizeGet>>> = ({
    signal
  }) => slackAuthorizationRedirectApiV1SlackAuthorizeGet(signal);

  const query = useQuery<Awaited<ReturnType<typeof slackAuthorizationRedirectApiV1SlackAuthorizeGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Finish slack installation.

When a user confirms application (bot) installation,
slack redirects him back to the 'redirect_uri' URL
provided within the authorization request.

Slack will include the next query parameters with the redirection URL:
code - access token exchange code
error - error message if something went wrong
state - installation state token that was passed with an authorization request.
 * @summary Slack-Installation-Callback
 */
export const slackInstallationCallbackApiV1SlackInstallGet = (
  params: SlackInstallationCallbackApiV1SlackInstallGetParams,
  signal?: AbortSignal
) => customInstance<unknown>({ url: `/api/v1/slack.install`, method: 'get', params, signal });

export const getSlackInstallationCallbackApiV1SlackInstallGetQueryKey = (
  params: SlackInstallationCallbackApiV1SlackInstallGetParams
) => [`/api/v1/slack.install`, ...(params ? [params] : [])];

export type SlackInstallationCallbackApiV1SlackInstallGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof slackInstallationCallbackApiV1SlackInstallGet>>
>;
export type SlackInstallationCallbackApiV1SlackInstallGetQueryError = ErrorType<HTTPValidationError>;

export const useSlackInstallationCallbackApiV1SlackInstallGet = <
  TData = Awaited<ReturnType<typeof slackInstallationCallbackApiV1SlackInstallGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  params: SlackInstallationCallbackApiV1SlackInstallGetParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof slackInstallationCallbackApiV1SlackInstallGet>>, TError, TData>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSlackInstallationCallbackApiV1SlackInstallGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof slackInstallationCallbackApiV1SlackInstallGet>>> = ({
    signal
  }) => slackInstallationCallbackApiV1SlackInstallGet(params, signal);

  const query = useQuery<Awaited<ReturnType<typeof slackInstallationCallbackApiV1SlackInstallGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Return list of slack installations.
 * @summary Retrieve Instalations
 */
export const retrieveInstalationsApiV1SlackAppsGet = (signal?: AbortSignal) =>
  customInstance<unknown>({ url: `/api/v1/slack/apps`, method: 'get', signal });

export const getRetrieveInstalationsApiV1SlackAppsGetQueryKey = () => [`/api/v1/slack/apps`];

export type RetrieveInstalationsApiV1SlackAppsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof retrieveInstalationsApiV1SlackAppsGet>>
>;
export type RetrieveInstalationsApiV1SlackAppsGetQueryError = ErrorType<unknown>;

export const useRetrieveInstalationsApiV1SlackAppsGet = <
  TData = Awaited<ReturnType<typeof retrieveInstalationsApiV1SlackAppsGet>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof retrieveInstalationsApiV1SlackAppsGet>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRetrieveInstalationsApiV1SlackAppsGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveInstalationsApiV1SlackAppsGet>>> = ({ signal }) =>
    retrieveInstalationsApiV1SlackAppsGet(signal);

  const query = useQuery<Awaited<ReturnType<typeof retrieveInstalationsApiV1SlackAppsGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Remove slack installation.
 * @summary Remove Installation
 */
export const removeInstallationApiV1SlackAppsAppIdDelete = (appId: number) =>
  customInstance<unknown>({ url: `/api/v1/slack/apps/${appId}`, method: 'delete' });

export type RemoveInstallationApiV1SlackAppsAppIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeInstallationApiV1SlackAppsAppIdDelete>>
>;

export type RemoveInstallationApiV1SlackAppsAppIdDeleteMutationError = ErrorType<HTTPValidationError>;

export const useRemoveInstallationApiV1SlackAppsAppIdDelete = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeInstallationApiV1SlackAppsAppIdDelete>>,
    TError,
    { appId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeInstallationApiV1SlackAppsAppIdDelete>>,
    { appId: number }
  > = props => {
    const { appId } = props ?? {};

    return removeInstallationApiV1SlackAppsAppIdDelete(appId);
  };

  return useMutation<
    Awaited<ReturnType<typeof removeInstallationApiV1SlackAppsAppIdDelete>>,
    TError,
    { appId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * @summary Health Check
 */
export const healthCheckApiV1HealthCheckGet = (signal?: AbortSignal) =>
  customInstance<unknown>({ url: `/api/v1/health-check`, method: 'get', signal });

export const getHealthCheckApiV1HealthCheckGetQueryKey = () => [`/api/v1/health-check`];

export type HealthCheckApiV1HealthCheckGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheckApiV1HealthCheckGet>>
>;
export type HealthCheckApiV1HealthCheckGetQueryError = ErrorType<unknown>;

export const useHealthCheckApiV1HealthCheckGet = <
  TData = Awaited<ReturnType<typeof healthCheckApiV1HealthCheckGet>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1HealthCheckGet>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthCheckApiV1HealthCheckGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckApiV1HealthCheckGet>>> = ({ signal }) =>
    healthCheckApiV1HealthCheckGet(signal);

  const query = useQuery<Awaited<ReturnType<typeof healthCheckApiV1HealthCheckGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * @summary Retrieve Feature Flags
 */
export const retrieveFeatureFlagsFeatureFlagsGet = (signal?: AbortSignal) =>
  customInstance<unknown>({ url: `/feature-flags`, method: 'get', signal });

export const getRetrieveFeatureFlagsFeatureFlagsGetQueryKey = () => [`/feature-flags`];

export type RetrieveFeatureFlagsFeatureFlagsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof retrieveFeatureFlagsFeatureFlagsGet>>
>;
export type RetrieveFeatureFlagsFeatureFlagsGetQueryError = ErrorType<unknown>;

export const useRetrieveFeatureFlagsFeatureFlagsGet = <
  TData = Awaited<ReturnType<typeof retrieveFeatureFlagsFeatureFlagsGet>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof retrieveFeatureFlagsFeatureFlagsGet>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRetrieveFeatureFlagsFeatureFlagsGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveFeatureFlagsFeatureFlagsGet>>> = ({ signal }) =>
    retrieveFeatureFlagsFeatureFlagsGet(signal);

  const query = useQuery<Awaited<ReturnType<typeof retrieveFeatureFlagsFeatureFlagsGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};
