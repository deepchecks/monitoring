/**
 * Generated by orval v6.9.6 ðŸº
 * Do not edit manually.
 * Deepchecks Monitoring
 * OpenAPI spec version: 0.1.0
 */
import { useQuery, useMutation } from '@tanstack/react-query';
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey
} from '@tanstack/react-query';
import { customInstance } from '../services/customAxios';
import type { ErrorType } from '../services/customAxios';
export type GetModelColumnsApiV1ModelsModelIdColumnsGet200 = { [key: string]: ColumnMetadata };

export type RetrieveModelsDataIngestionApiV1ModelsDataIngestionGet200 = { [key: string]: ModelDailyIngestion[] };

export type RetrieveModelsDataIngestionApiV1ModelsDataIngestionGetParams = { model_id?: number; time_filter?: number };

export type RetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGetParams = { time_filter?: number };

export type UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutBodyItem = { [key: string]: any };

export type LogDataBatchApiV1ModelVersionsModelVersionIdDataPostBodyItem = { [key: string]: any };

export type DeleteCheckByNameApiV1ModelsModelIdChecksDeleteParams = { names: string[] };

export type CreateCheckApiV1ModelsModelIdChecksPost200 = IdResponse | IdResponse[];

export type GetAlertRulesApiV1AlertRulesGetSortbyItem =
  typeof GetAlertRulesApiV1AlertRulesGetSortbyItem[keyof typeof GetAlertRulesApiV1AlertRulesGetSortbyItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetAlertRulesApiV1AlertRulesGetSortbyItem = {
  severityasc: 'severity:asc',
  severitydesc: 'severity:desc',
  'alert-windowasc': 'alert-window:asc',
  'alert-windowdesc': 'alert-window:desc'
} as const;

export type GetAlertRulesApiV1AlertRulesGetParams = {
  monitor_id?: number;
  start?: string;
  end?: string;
  models?: number[];
  severity?: AlertSeverity[];
  sortby?: GetAlertRulesApiV1AlertRulesGetSortbyItem[];
};

export type CountAlertRulesApiV1AlertRulesCountGet200 = { [key: string]: number };

export type CountAlertRulesApiV1AlertRulesCountGetParams = { model_id?: number };

export type CountAlertRulesApiV1ModelsModelIdAlertRulesCountGet200 = { [key: string]: number };

export type GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetSortbyItem =
  typeof GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetSortbyItem[keyof typeof GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetSortbyItem];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetSortbyItem = {
  severityasc: 'severity:asc',
  severitydesc: 'severity:desc',
  'alert-windowasc': 'alert-window:asc',
  'alert-windowdesc': 'alert-window:desc'
} as const;

export type GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetParams = {
  start?: string;
  end?: string;
  models?: number[];
  severity?: AlertSeverity[];
  sortby?: GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetSortbyItem[];
};

export type CountAlertsApiV1AlertsCountActiveGet200 = { [key: string]: number };

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

/**
 * Enum containing supported task types.
 */
export type TaskType = unknown;

/**
 * Operators for numeric and categorical filters.
 */
export type OperatorsEnum = unknown;

/**
 * Schema defines the parameters for creating new monitor.
 */
export interface MonitorUpdateSchema {
  name?: string;
  lookback?: string;
  description?: string;
  data_filters?: DataFilterList;
  dashboard_id?: number;
  filter_key?: string;
}

/**
 * Schema for the monitor.
 */
export interface MonitorSchema {
  id: number;
  name: string;
  check: CheckSchema;
  dashboard_id?: number;
  lookback: number;
  description?: string;
  data_filters?: DataFilterList;
  filter_key?: string;
  alert_rules: AlertRuleSchema[];
}

/**
 * Schema defines the parameters for creating new monitor.
 */
export interface MonitorRunSchema {
  end_time?: string;
}

/**
 * Monitor run schema.
 */
export interface MonitorOptions {
  end_time: string;
  start_time: string;
  filter?: DataFilterList;
}

/**
 * Schema defines the parameters for creating new monitor.
 */
export interface MonitorCreationSchema {
  name: string;
  lookback: number;
  dashboard_id?: number;
  description?: string;
  data_filters?: DataFilterList;
  filter_key?: string;
}

/**
 * Model ingestion record.
 */
export interface ModelsInfoSchema {
  id: number;
  name: string;
  description?: string;
  task_type?: TaskType;
  alerts_count?: number;
  latest_time?: number;
}

export type ModelVersionCreationSchemaFeatureImportance = { [key: string]: number };

export type ModelVersionCreationSchemaNonFeatures = { [key: string]: ColumnType };

export type ModelVersionCreationSchemaFeatures = { [key: string]: ColumnType };

/**
 * Schema defines the parameters for creating new model version.
 */
export interface ModelVersionCreationSchema {
  name: string;
  features: ModelVersionCreationSchemaFeatures;
  non_features: ModelVersionCreationSchemaNonFeatures;
  feature_importance?: ModelVersionCreationSchemaFeatureImportance;
}

/**
 * Model Schema.
 */
export interface ModelSchema {
  id: number;
  name: string;
  description?: string;
  task_type?: TaskType;
}

export interface ModelDailyIngestion {
  count: number;
  day: number;
}

/**
 * Model schema.
 */
export interface ModelCreationSchema {
  name: string;
  task_type: TaskType;
  description?: string;
}

/**
 * Schema defines a response containing only id.
 */
export interface IdResponse {
  id: number;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * Filter to be used on data, column can be feature/non-feature and value can be numeric/string.
 */
export interface DataFilter {
  column: string;
  operator: OperatorsEnum;
  value?: unknown;
}

/**
 * List of data filters.
 */
export interface DataFilterList {
  filters: DataFilter[];
}

/**
 * Window with filter run schema.
 */
export interface FilterWindowOptions {
  end_time: string;
  start_time: string;
  filter?: DataFilterList;
  model_version_ids?: number[];
}

/**
 * Schema defines the parameters for updating a dashboard.
 */
export interface DashboardUpdateSchema {
  name: string;
}

/**
 * Schema for the dashboard.
 */
export interface DashboardSchema {
  id: number;
  name?: string;
  monitors: MonitorSchema[];
}

/**
 * Condition to define an alert on check result, value must be numeric.
 */
export interface Condition {
  operator: OperatorsEnum;
  value: number;
}

/**
 * Enum containing possible types of data.
 */
export type ColumnType = unknown;

export type ColumnMetadataStats = { [key: string]: any };

export interface ColumnMetadata {
  type: ColumnType;
  stats: ColumnMetadataStats;
}

export type CheckResultSchemaOutput = { [key: string]: any };

/**
 * Check run result schema.
 */
export interface CheckResultSchema {
  output: CheckResultSchemaOutput;
  time_labels: string[];
}

export type CheckConfigSchemaParams = { [key: string]: any };

export interface CheckConfigSchema {
  module_name: string;
  class_name: string;
  params: CheckConfigSchemaParams;
}

/**
 * Schema for the check.
 */
export interface CheckSchema {
  config: CheckConfigSchema;
  model_id: number;
  id: number;
  name?: string;
}

export interface BodySaveReferenceApiV1ModelVersionsModelVersionIdReferencePost {
  file: Blob;
}

/**
 * Enum for the alert severity.
 */
export type AlertSeverity = typeof AlertSeverity[keyof typeof AlertSeverity];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AlertSeverity = {
  low: 'low',
  mid: 'mid',
  high: 'high',
  critical: 'critical'
} as const;

export type AlertSchemaFailedValues = { [key: string]: string[] };

/**
 * Schema for the alert.
 */
export interface AlertSchema {
  id: number;
  alert_rule_id: number;
  failed_values: AlertSchemaFailedValues;
  start_time: string;
  end_time: string;
  resolved: boolean;
  created_at: string;
}

/**
 * Schema defines the parameters for updating alert rule.
 */
export interface AlertRuleUpdateSchema {
  name?: string;
  repeat_every?: number;
  alert_severity?: AlertSeverity;
  condition?: Condition;
}

/**
 * Schema for the alert rule.
 */
export interface AlertRuleSchema {
  id: number;
  name: string;
  monitor_id: number;
  repeat_every: number;
  condition: Condition;
  alert_severity?: AlertSeverity;
}

/**
 * Schema of alert rule info for display.
 */
export interface AlertRuleInfoSchema {
  id: number;
  name: string;
  monitor_id: number;
  repeat_every: number;
  condition: Condition;
  alert_severity?: AlertSeverity;
  model_id: number;
  alerts_count?: number;
}

/**
 * Schema defines the parameters for creating new alert rule.
 */
export interface AlertRuleCreationSchema {
  condition: Condition;
  repeat_every: number;
  alert_severity?: AlertSeverity;
  name?: string;
}

/**
 * @summary Hello World
 */
export const helloWorldApiV1SayHelloGet = (signal?: AbortSignal) =>
  customInstance<unknown>({ url: `/api/v1/say-hello`, method: 'get', signal });

export const getHelloWorldApiV1SayHelloGetQueryKey = () => [`/api/v1/say-hello`];

export type HelloWorldApiV1SayHelloGetQueryResult = NonNullable<Awaited<ReturnType<typeof helloWorldApiV1SayHelloGet>>>;
export type HelloWorldApiV1SayHelloGetQueryError = ErrorType<unknown>;

export const useHelloWorldApiV1SayHelloGet = <
  TData = Awaited<ReturnType<typeof helloWorldApiV1SayHelloGet>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof helloWorldApiV1SayHelloGet>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHelloWorldApiV1SayHelloGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof helloWorldApiV1SayHelloGet>>> = ({ signal }) =>
    helloWorldApiV1SayHelloGet(signal);

  const query = useQuery<Awaited<ReturnType<typeof helloWorldApiV1SayHelloGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Count alerts.
 * @summary Count Alerts
 */
export const countAlertsApiV1AlertsCountActiveGet = (signal?: AbortSignal) =>
  customInstance<CountAlertsApiV1AlertsCountActiveGet200>({
    url: `/api/v1/alerts/count_active`,
    method: 'get',
    signal
  });

export const getCountAlertsApiV1AlertsCountActiveGetQueryKey = () => [`/api/v1/alerts/count_active`];

export type CountAlertsApiV1AlertsCountActiveGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof countAlertsApiV1AlertsCountActiveGet>>
>;
export type CountAlertsApiV1AlertsCountActiveGetQueryError = ErrorType<unknown>;

export const useCountAlertsApiV1AlertsCountActiveGet = <
  TData = Awaited<ReturnType<typeof countAlertsApiV1AlertsCountActiveGet>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof countAlertsApiV1AlertsCountActiveGet>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCountAlertsApiV1AlertsCountActiveGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countAlertsApiV1AlertsCountActiveGet>>> = ({ signal }) =>
    countAlertsApiV1AlertsCountActiveGet(signal);

  const query = useQuery<Awaited<ReturnType<typeof countAlertsApiV1AlertsCountActiveGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Resolve alert by id.
 * @summary Resolve Alert
 */
export const resolveAlertApiV1AlertsAlertIdResolvePost = (alertId: number) =>
  customInstance<unknown>({ url: `/api/v1/alerts/${alertId}/resolve`, method: 'post' });

export type ResolveAlertApiV1AlertsAlertIdResolvePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof resolveAlertApiV1AlertsAlertIdResolvePost>>
>;

export type ResolveAlertApiV1AlertsAlertIdResolvePostMutationError = ErrorType<HTTPValidationError>;

export const useResolveAlertApiV1AlertsAlertIdResolvePost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resolveAlertApiV1AlertsAlertIdResolvePost>>,
    TError,
    { alertId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resolveAlertApiV1AlertsAlertIdResolvePost>>,
    { alertId: number }
  > = props => {
    const { alertId } = props ?? {};

    return resolveAlertApiV1AlertsAlertIdResolvePost(alertId);
  };

  return useMutation<
    Awaited<ReturnType<typeof resolveAlertApiV1AlertsAlertIdResolvePost>>,
    TError,
    { alertId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Get alert by id.
 * @summary Get Alert
 */
export const getAlertApiV1AlertsAlertIdGet = (alertId: number, signal?: AbortSignal) =>
  customInstance<AlertSchema>({ url: `/api/v1/alerts/${alertId}`, method: 'get', signal });

export const getGetAlertApiV1AlertsAlertIdGetQueryKey = (alertId: number) => [`/api/v1/alerts/${alertId}`];

export type GetAlertApiV1AlertsAlertIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAlertApiV1AlertsAlertIdGet>>
>;
export type GetAlertApiV1AlertsAlertIdGetQueryError = ErrorType<HTTPValidationError>;

export const useGetAlertApiV1AlertsAlertIdGet = <
  TData = Awaited<ReturnType<typeof getAlertApiV1AlertsAlertIdGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  alertId: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getAlertApiV1AlertsAlertIdGet>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAlertApiV1AlertsAlertIdGetQueryKey(alertId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAlertApiV1AlertsAlertIdGet>>> = ({ signal }) =>
    getAlertApiV1AlertsAlertIdGet(alertId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getAlertApiV1AlertsAlertIdGet>>, TError, TData>(queryKey, queryFn, {
    enabled: !!alertId,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Delete alert by id.
 * @summary Delete Alert
 */
export const deleteAlertApiV1AlertsAlertIdDelete = (alertId: number) =>
  customInstance<unknown>({ url: `/api/v1/alerts/${alertId}`, method: 'delete' });

export type DeleteAlertApiV1AlertsAlertIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAlertApiV1AlertsAlertIdDelete>>
>;

export type DeleteAlertApiV1AlertsAlertIdDeleteMutationError = ErrorType<HTTPValidationError>;

export const useDeleteAlertApiV1AlertsAlertIdDelete = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAlertApiV1AlertsAlertIdDelete>>,
    TError,
    { alertId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAlertApiV1AlertsAlertIdDelete>>,
    { alertId: number }
  > = props => {
    const { alertId } = props ?? {};

    return deleteAlertApiV1AlertsAlertIdDelete(alertId);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteAlertApiV1AlertsAlertIdDelete>>,
    TError,
    { alertId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Create new alert rule on a given check.
 * @summary Create new alert rule on a given monitor.
 */
export const createAlertRuleApiV1MonitorsMonitorIdAlertRulesPost = (
  monitorId: number,
  alertRuleCreationSchema: AlertRuleCreationSchema
) =>
  customInstance<IdResponse>({
    url: `/api/v1/monitors/${monitorId}/alert-rules`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: alertRuleCreationSchema
  });

export type CreateAlertRuleApiV1MonitorsMonitorIdAlertRulesPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAlertRuleApiV1MonitorsMonitorIdAlertRulesPost>>
>;
export type CreateAlertRuleApiV1MonitorsMonitorIdAlertRulesPostMutationBody = AlertRuleCreationSchema;
export type CreateAlertRuleApiV1MonitorsMonitorIdAlertRulesPostMutationError = ErrorType<HTTPValidationError>;

export const useCreateAlertRuleApiV1MonitorsMonitorIdAlertRulesPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAlertRuleApiV1MonitorsMonitorIdAlertRulesPost>>,
    TError,
    { monitorId: number; data: AlertRuleCreationSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAlertRuleApiV1MonitorsMonitorIdAlertRulesPost>>,
    { monitorId: number; data: AlertRuleCreationSchema }
  > = props => {
    const { monitorId, data } = props ?? {};

    return createAlertRuleApiV1MonitorsMonitorIdAlertRulesPost(monitorId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof createAlertRuleApiV1MonitorsMonitorIdAlertRulesPost>>,
    TError,
    { monitorId: number; data: AlertRuleCreationSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Return all the alert rules.

Parameters
----------
monitor_id : int
    ID of a monitor to filter alert rules by.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
List[AlertSchema]
    All the alerts for a given monitor.
 * @summary Get Alert Rules
 */
export const getAlertRulesApiV1MonitorsMonitorIdAlertRulesGet = (
  monitorId: number,
  params?: GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetParams,
  signal?: AbortSignal
) =>
  customInstance<AlertRuleInfoSchema[]>({
    url: `/api/v1/monitors/${monitorId}/alert-rules`,
    method: 'get',
    params,
    signal
  });

export const getGetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetQueryKey = (
  monitorId: number,
  params?: GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetParams
) => [`/api/v1/monitors/${monitorId}/alert-rules`, ...(params ? [params] : [])];

export type GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAlertRulesApiV1MonitorsMonitorIdAlertRulesGet>>
>;
export type GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetQueryError = ErrorType<HTTPValidationError>;

export const useGetAlertRulesApiV1MonitorsMonitorIdAlertRulesGet = <
  TData = Awaited<ReturnType<typeof getAlertRulesApiV1MonitorsMonitorIdAlertRulesGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  monitorId: number,
  params?: GetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAlertRulesApiV1MonitorsMonitorIdAlertRulesGet>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAlertRulesApiV1MonitorsMonitorIdAlertRulesGetQueryKey(monitorId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAlertRulesApiV1MonitorsMonitorIdAlertRulesGet>>> = ({
    signal
  }) => getAlertRulesApiV1MonitorsMonitorIdAlertRulesGet(monitorId, params, signal);

  const query = useQuery<Awaited<ReturnType<typeof getAlertRulesApiV1MonitorsMonitorIdAlertRulesGet>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!monitorId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Count alerts.
 * @summary Count Alert Rules
 */
export const countAlertRulesApiV1ModelsModelIdAlertRulesCountGet = (modelId: number, signal?: AbortSignal) =>
  customInstance<CountAlertRulesApiV1ModelsModelIdAlertRulesCountGet200>({
    url: `/api/v1/models/${modelId}/alert-rules/count`,
    method: 'get',
    signal
  });

export const getCountAlertRulesApiV1ModelsModelIdAlertRulesCountGetQueryKey = (modelId: number) => [
  `/api/v1/models/${modelId}/alert-rules/count`
];

export type CountAlertRulesApiV1ModelsModelIdAlertRulesCountGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof countAlertRulesApiV1ModelsModelIdAlertRulesCountGet>>
>;
export type CountAlertRulesApiV1ModelsModelIdAlertRulesCountGetQueryError = ErrorType<HTTPValidationError>;

export const useCountAlertRulesApiV1ModelsModelIdAlertRulesCountGet = <
  TData = Awaited<ReturnType<typeof countAlertRulesApiV1ModelsModelIdAlertRulesCountGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  modelId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof countAlertRulesApiV1ModelsModelIdAlertRulesCountGet>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCountAlertRulesApiV1ModelsModelIdAlertRulesCountGetQueryKey(modelId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countAlertRulesApiV1ModelsModelIdAlertRulesCountGet>>> = ({
    signal
  }) => countAlertRulesApiV1ModelsModelIdAlertRulesCountGet(modelId, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof countAlertRulesApiV1ModelsModelIdAlertRulesCountGet>>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!modelId, ...queryOptions }) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * Count alerts.
 * @summary Count Alert Rules
 */
export const countAlertRulesApiV1AlertRulesCountGet = (
  params?: CountAlertRulesApiV1AlertRulesCountGetParams,
  signal?: AbortSignal
) =>
  customInstance<CountAlertRulesApiV1AlertRulesCountGet200>({
    url: `/api/v1/alert-rules/count`,
    method: 'get',
    params,
    signal
  });

export const getCountAlertRulesApiV1AlertRulesCountGetQueryKey = (
  params?: CountAlertRulesApiV1AlertRulesCountGetParams
) => [`/api/v1/alert-rules/count`, ...(params ? [params] : [])];

export type CountAlertRulesApiV1AlertRulesCountGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof countAlertRulesApiV1AlertRulesCountGet>>
>;
export type CountAlertRulesApiV1AlertRulesCountGetQueryError = ErrorType<HTTPValidationError>;

export const useCountAlertRulesApiV1AlertRulesCountGet = <
  TData = Awaited<ReturnType<typeof countAlertRulesApiV1AlertRulesCountGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: CountAlertRulesApiV1AlertRulesCountGetParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof countAlertRulesApiV1AlertRulesCountGet>>, TError, TData>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCountAlertRulesApiV1AlertRulesCountGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countAlertRulesApiV1AlertRulesCountGet>>> = ({ signal }) =>
    countAlertRulesApiV1AlertRulesCountGet(params, signal);

  const query = useQuery<Awaited<ReturnType<typeof countAlertRulesApiV1AlertRulesCountGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Return all the alert rules.

Parameters
----------
monitor_id : int
    ID of a monitor to filter alert rules by.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
List[AlertSchema]
    All the alerts for a given monitor.
 * @summary Get Alert Rules
 */
export const getAlertRulesApiV1AlertRulesGet = (params?: GetAlertRulesApiV1AlertRulesGetParams, signal?: AbortSignal) =>
  customInstance<AlertRuleInfoSchema[]>({ url: `/api/v1/alert-rules`, method: 'get', params, signal });

export const getGetAlertRulesApiV1AlertRulesGetQueryKey = (params?: GetAlertRulesApiV1AlertRulesGetParams) => [
  `/api/v1/alert-rules`,
  ...(params ? [params] : [])
];

export type GetAlertRulesApiV1AlertRulesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAlertRulesApiV1AlertRulesGet>>
>;
export type GetAlertRulesApiV1AlertRulesGetQueryError = ErrorType<HTTPValidationError>;

export const useGetAlertRulesApiV1AlertRulesGet = <
  TData = Awaited<ReturnType<typeof getAlertRulesApiV1AlertRulesGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: GetAlertRulesApiV1AlertRulesGetParams,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getAlertRulesApiV1AlertRulesGet>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAlertRulesApiV1AlertRulesGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAlertRulesApiV1AlertRulesGet>>> = ({ signal }) =>
    getAlertRulesApiV1AlertRulesGet(params, signal);

  const query = useQuery<Awaited<ReturnType<typeof getAlertRulesApiV1AlertRulesGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Get alert by id.
 * @summary Get Alert Rule
 */
export const getAlertRuleApiV1AlertRulesAlertRuleIdGet = (alertRuleId: number, signal?: AbortSignal) =>
  customInstance<AlertRuleSchema>({ url: `/api/v1/alert-rules/${alertRuleId}`, method: 'get', signal });

export const getGetAlertRuleApiV1AlertRulesAlertRuleIdGetQueryKey = (alertRuleId: number) => [
  `/api/v1/alert-rules/${alertRuleId}`
];

export type GetAlertRuleApiV1AlertRulesAlertRuleIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAlertRuleApiV1AlertRulesAlertRuleIdGet>>
>;
export type GetAlertRuleApiV1AlertRulesAlertRuleIdGetQueryError = ErrorType<HTTPValidationError>;

export const useGetAlertRuleApiV1AlertRulesAlertRuleIdGet = <
  TData = Awaited<ReturnType<typeof getAlertRuleApiV1AlertRulesAlertRuleIdGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  alertRuleId: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getAlertRuleApiV1AlertRulesAlertRuleIdGet>>, TError, TData>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAlertRuleApiV1AlertRulesAlertRuleIdGetQueryKey(alertRuleId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAlertRuleApiV1AlertRulesAlertRuleIdGet>>> = ({ signal }) =>
    getAlertRuleApiV1AlertRulesAlertRuleIdGet(alertRuleId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getAlertRuleApiV1AlertRulesAlertRuleIdGet>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!alertRuleId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Update alert by id.
 * @summary Update alert rule by id.
 */
export const updateAlertApiV1AlertRulesAlertRuleIdPut = (
  alertRuleId: number,
  alertRuleUpdateSchema: AlertRuleUpdateSchema
) =>
  customInstance<unknown>({
    url: `/api/v1/alert-rules/${alertRuleId}`,
    method: 'put',
    headers: { 'Content-Type': 'application/json' },
    data: alertRuleUpdateSchema
  });

export type UpdateAlertApiV1AlertRulesAlertRuleIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAlertApiV1AlertRulesAlertRuleIdPut>>
>;
export type UpdateAlertApiV1AlertRulesAlertRuleIdPutMutationBody = AlertRuleUpdateSchema;
export type UpdateAlertApiV1AlertRulesAlertRuleIdPutMutationError = ErrorType<HTTPValidationError>;

export const useUpdateAlertApiV1AlertRulesAlertRuleIdPut = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAlertApiV1AlertRulesAlertRuleIdPut>>,
    TError,
    { alertRuleId: number; data: AlertRuleUpdateSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAlertApiV1AlertRulesAlertRuleIdPut>>,
    { alertRuleId: number; data: AlertRuleUpdateSchema }
  > = props => {
    const { alertRuleId, data } = props ?? {};

    return updateAlertApiV1AlertRulesAlertRuleIdPut(alertRuleId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof updateAlertApiV1AlertRulesAlertRuleIdPut>>,
    TError,
    { alertRuleId: number; data: AlertRuleUpdateSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Delete alert by id.
 * @summary Delete Alert Rule
 */
export const deleteAlertRuleApiV1AlertRulesAlertRuleIdDelete = (alertRuleId: number) =>
  customInstance<unknown>({ url: `/api/v1/alert-rules/${alertRuleId}`, method: 'delete' });

export type DeleteAlertRuleApiV1AlertRulesAlertRuleIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAlertRuleApiV1AlertRulesAlertRuleIdDelete>>
>;

export type DeleteAlertRuleApiV1AlertRulesAlertRuleIdDeleteMutationError = ErrorType<HTTPValidationError>;

export const useDeleteAlertRuleApiV1AlertRulesAlertRuleIdDelete = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAlertRuleApiV1AlertRulesAlertRuleIdDelete>>,
    TError,
    { alertRuleId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAlertRuleApiV1AlertRulesAlertRuleIdDelete>>,
    { alertRuleId: number }
  > = props => {
    const { alertRuleId } = props ?? {};

    return deleteAlertRuleApiV1AlertRulesAlertRuleIdDelete(alertRuleId);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteAlertRuleApiV1AlertRulesAlertRuleIdDelete>>,
    TError,
    { alertRuleId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Delete alert by id.
 * @summary Get Alerts Of Alert Rule
 */
export const getAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGet = (alertRuleId: number, signal?: AbortSignal) =>
  customInstance<AlertSchema[]>({ url: `/api/v1/alert-rules/${alertRuleId}/alerts`, method: 'get', signal });

export const getGetAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGetQueryKey = (alertRuleId: number) => [
  `/api/v1/alert-rules/${alertRuleId}/alerts`
];

export type GetAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGet>>
>;
export type GetAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGetQueryError = ErrorType<HTTPValidationError>;

export const useGetAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGet = <
  TData = Awaited<ReturnType<typeof getAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  alertRuleId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGet>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGetQueryKey(alertRuleId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGet>>> = ({
    signal
  }) => getAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGet(alertRuleId, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof getAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdAlertsGet>>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!alertRuleId, ...queryOptions }) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * Resolve all alerts of alert rule.
 * @summary Resolve All Alerts Of Alert Rule
 */
export const resolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPost = (alertRuleId: number) =>
  customInstance<unknown>({ url: `/api/v1/alert-rules/${alertRuleId}/resolve-all`, method: 'post' });

export type ResolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof resolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPost>>
>;

export type ResolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPostMutationError =
  ErrorType<HTTPValidationError>;

export const useResolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPost>>,
    TError,
    { alertRuleId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPost>>,
    { alertRuleId: number }
  > = props => {
    const { alertRuleId } = props ?? {};

    return resolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPost(alertRuleId);
  };

  return useMutation<
    Awaited<ReturnType<typeof resolveAllAlertsOfAlertRuleApiV1AlertRulesAlertRuleIdResolveAllPost>>,
    TError,
    { alertRuleId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Create a new check.

Parameters
----------
model_id : int
    ID of the model.
check : CheckCreationSchema
    Check to create.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
int
    The check id.
 * @summary Create Check
 */
export const createCheckApiV1ModelsModelIdChecksPost = (
  modelId: number,
  createCheckApiV1ModelsModelIdChecksPostBody: unknown
) =>
  customInstance<CreateCheckApiV1ModelsModelIdChecksPost200>({
    url: `/api/v1/models/${modelId}/checks`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: createCheckApiV1ModelsModelIdChecksPostBody
  });

export type CreateCheckApiV1ModelsModelIdChecksPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createCheckApiV1ModelsModelIdChecksPost>>
>;
export type CreateCheckApiV1ModelsModelIdChecksPostMutationBody = unknown;
export type CreateCheckApiV1ModelsModelIdChecksPostMutationError = ErrorType<HTTPValidationError>;

export const useCreateCheckApiV1ModelsModelIdChecksPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCheckApiV1ModelsModelIdChecksPost>>,
    TError,
    { modelId: number; data: unknown },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCheckApiV1ModelsModelIdChecksPost>>,
    { modelId: number; data: unknown }
  > = props => {
    const { modelId, data } = props ?? {};

    return createCheckApiV1ModelsModelIdChecksPost(modelId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof createCheckApiV1ModelsModelIdChecksPost>>,
    TError,
    { modelId: number; data: unknown },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Delete check instances by name.
 * @summary Delete Check By Name
 */
export const deleteCheckByNameApiV1ModelsModelIdChecksDelete = (
  modelId: number,
  params: DeleteCheckByNameApiV1ModelsModelIdChecksDeleteParams
) => customInstance<unknown>({ url: `/api/v1/models/${modelId}/checks`, method: 'delete', params });

export type DeleteCheckByNameApiV1ModelsModelIdChecksDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteCheckByNameApiV1ModelsModelIdChecksDelete>>
>;

export type DeleteCheckByNameApiV1ModelsModelIdChecksDeleteMutationError = ErrorType<HTTPValidationError>;

export const useDeleteCheckByNameApiV1ModelsModelIdChecksDelete = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCheckByNameApiV1ModelsModelIdChecksDelete>>,
    TError,
    { modelId: number; params: DeleteCheckByNameApiV1ModelsModelIdChecksDeleteParams },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteCheckByNameApiV1ModelsModelIdChecksDelete>>,
    { modelId: number; params: DeleteCheckByNameApiV1ModelsModelIdChecksDeleteParams }
  > = props => {
    const { modelId, params } = props ?? {};

    return deleteCheckByNameApiV1ModelsModelIdChecksDelete(modelId, params);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteCheckByNameApiV1ModelsModelIdChecksDelete>>,
    TError,
    { modelId: number; params: DeleteCheckByNameApiV1ModelsModelIdChecksDeleteParams },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Return all the checks for a given model.

Parameters
----------
model_id : int
    ID of the model.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
List[CheckSchema]
    All the checks for a given model.
 * @summary Get Checks
 */
export const getChecksApiV1ModelsModelIdChecksGet = (modelId: number, signal?: AbortSignal) =>
  customInstance<CheckSchema[]>({ url: `/api/v1/models/${modelId}/checks`, method: 'get', signal });

export const getGetChecksApiV1ModelsModelIdChecksGetQueryKey = (modelId: number) => [
  `/api/v1/models/${modelId}/checks`
];

export type GetChecksApiV1ModelsModelIdChecksGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getChecksApiV1ModelsModelIdChecksGet>>
>;
export type GetChecksApiV1ModelsModelIdChecksGetQueryError = ErrorType<HTTPValidationError>;

export const useGetChecksApiV1ModelsModelIdChecksGet = <
  TData = Awaited<ReturnType<typeof getChecksApiV1ModelsModelIdChecksGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  modelId: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getChecksApiV1ModelsModelIdChecksGet>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetChecksApiV1ModelsModelIdChecksGetQueryKey(modelId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getChecksApiV1ModelsModelIdChecksGet>>> = ({ signal }) =>
    getChecksApiV1ModelsModelIdChecksGet(modelId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getChecksApiV1ModelsModelIdChecksGet>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!modelId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Delete check instance by identifier.
 * @summary Delete Check
 */
export const deleteCheckApiV1ModelsModelIdChecksCheckIdDelete = (modelId: number, checkId: number) =>
  customInstance<unknown>({ url: `/api/v1/models/${modelId}/checks/${checkId}`, method: 'delete' });

export type DeleteCheckApiV1ModelsModelIdChecksCheckIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteCheckApiV1ModelsModelIdChecksCheckIdDelete>>
>;

export type DeleteCheckApiV1ModelsModelIdChecksCheckIdDeleteMutationError = ErrorType<HTTPValidationError>;

export const useDeleteCheckApiV1ModelsModelIdChecksCheckIdDelete = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCheckApiV1ModelsModelIdChecksCheckIdDelete>>,
    TError,
    { modelId: number; checkId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteCheckApiV1ModelsModelIdChecksCheckIdDelete>>,
    { modelId: number; checkId: number }
  > = props => {
    const { modelId, checkId } = props ?? {};

    return deleteCheckApiV1ModelsModelIdChecksCheckIdDelete(modelId, checkId);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteCheckApiV1ModelsModelIdChecksCheckIdDelete>>,
    TError,
    { modelId: number; checkId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Run a check for each time window by start-end.

Parameters
----------
check_id : int
    ID of the check.
monitor_options : MonitorOptions
    The "monitor" options.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
CheckSchema
    Created check.
 * @summary Run Standalone Check Per Window In Range
 */
export const runStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPost = (
  checkId: number,
  monitorOptions: MonitorOptions
) =>
  customInstance<CheckResultSchema>({
    url: `/api/v1/checks/${checkId}/run/lookback`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: monitorOptions
  });

export type RunStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof runStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPost>>
>;
export type RunStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPostMutationBody = MonitorOptions;
export type RunStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPostMutationError =
  ErrorType<HTTPValidationError>;

export const useRunStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPost>>,
    TError,
    { checkId: number; data: MonitorOptions },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPost>>,
    { checkId: number; data: MonitorOptions }
  > = props => {
    const { checkId, data } = props ?? {};

    return runStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPost(checkId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runStandaloneCheckPerWindowInRangeApiV1ChecksCheckIdRunLookbackPost>>,
    TError,
    { checkId: number; data: MonitorOptions },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Run a check for the time window.

Parameters
----------
check_id : int
    ID of the check.
window_options : FilterWindowOptions
    The window options.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
CheckSchema
    Created check.
 * @summary Get Check Window
 */
export const getCheckWindowApiV1ChecksCheckIdRunWindowPost = (
  checkId: number,
  filterWindowOptions: FilterWindowOptions
) =>
  customInstance<unknown>({
    url: `/api/v1/checks/${checkId}/run/window`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: filterWindowOptions
  });

export type GetCheckWindowApiV1ChecksCheckIdRunWindowPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof getCheckWindowApiV1ChecksCheckIdRunWindowPost>>
>;
export type GetCheckWindowApiV1ChecksCheckIdRunWindowPostMutationBody = FilterWindowOptions;
export type GetCheckWindowApiV1ChecksCheckIdRunWindowPostMutationError = ErrorType<HTTPValidationError>;

export const useGetCheckWindowApiV1ChecksCheckIdRunWindowPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getCheckWindowApiV1ChecksCheckIdRunWindowPost>>,
    TError,
    { checkId: number; data: FilterWindowOptions },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getCheckWindowApiV1ChecksCheckIdRunWindowPost>>,
    { checkId: number; data: FilterWindowOptions }
  > = props => {
    const { checkId, data } = props ?? {};

    return getCheckWindowApiV1ChecksCheckIdRunWindowPost(checkId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof getCheckWindowApiV1ChecksCheckIdRunWindowPost>>,
    TError,
    { checkId: number; data: FilterWindowOptions },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Create a new monitor based on a check. This endpoint requires the name, lookback, data_filter and description of the monitor.
 * @summary Create a new monitor.
 */
export const createMonitorApiV1ChecksCheckIdMonitorsPost = (
  checkId: number,
  monitorCreationSchema: MonitorCreationSchema
) =>
  customInstance<IdResponse>({
    url: `/api/v1/checks/${checkId}/monitors`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: monitorCreationSchema
  });

export type CreateMonitorApiV1ChecksCheckIdMonitorsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createMonitorApiV1ChecksCheckIdMonitorsPost>>
>;
export type CreateMonitorApiV1ChecksCheckIdMonitorsPostMutationBody = MonitorCreationSchema;
export type CreateMonitorApiV1ChecksCheckIdMonitorsPostMutationError = ErrorType<HTTPValidationError>;

export const useCreateMonitorApiV1ChecksCheckIdMonitorsPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createMonitorApiV1ChecksCheckIdMonitorsPost>>,
    TError,
    { checkId: number; data: MonitorCreationSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createMonitorApiV1ChecksCheckIdMonitorsPost>>,
    { checkId: number; data: MonitorCreationSchema }
  > = props => {
    const { checkId, data } = props ?? {};

    return createMonitorApiV1ChecksCheckIdMonitorsPost(checkId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof createMonitorApiV1ChecksCheckIdMonitorsPost>>,
    TError,
    { checkId: number; data: MonitorCreationSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Get monitor by id.
 * @summary Get Monitor
 */
export const getMonitorApiV1MonitorsMonitorIdGet = (monitorId: number, signal?: AbortSignal) =>
  customInstance<MonitorSchema>({ url: `/api/v1/monitors/${monitorId}`, method: 'get', signal });

export const getGetMonitorApiV1MonitorsMonitorIdGetQueryKey = (monitorId: number) => [`/api/v1/monitors/${monitorId}`];

export type GetMonitorApiV1MonitorsMonitorIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMonitorApiV1MonitorsMonitorIdGet>>
>;
export type GetMonitorApiV1MonitorsMonitorIdGetQueryError = ErrorType<HTTPValidationError>;

export const useGetMonitorApiV1MonitorsMonitorIdGet = <
  TData = Awaited<ReturnType<typeof getMonitorApiV1MonitorsMonitorIdGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  monitorId: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getMonitorApiV1MonitorsMonitorIdGet>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMonitorApiV1MonitorsMonitorIdGetQueryKey(monitorId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMonitorApiV1MonitorsMonitorIdGet>>> = ({ signal }) =>
    getMonitorApiV1MonitorsMonitorIdGet(monitorId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getMonitorApiV1MonitorsMonitorIdGet>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!monitorId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Update monitor by id.
 * @summary Update Monitor
 */
export const updateMonitorApiV1MonitorsMonitorIdPut = (monitorId: number, monitorUpdateSchema: MonitorUpdateSchema) =>
  customInstance<unknown>({
    url: `/api/v1/monitors/${monitorId}`,
    method: 'put',
    headers: { 'Content-Type': 'application/json' },
    data: monitorUpdateSchema
  });

export type UpdateMonitorApiV1MonitorsMonitorIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateMonitorApiV1MonitorsMonitorIdPut>>
>;
export type UpdateMonitorApiV1MonitorsMonitorIdPutMutationBody = MonitorUpdateSchema;
export type UpdateMonitorApiV1MonitorsMonitorIdPutMutationError = ErrorType<HTTPValidationError>;

export const useUpdateMonitorApiV1MonitorsMonitorIdPut = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMonitorApiV1MonitorsMonitorIdPut>>,
    TError,
    { monitorId: number; data: MonitorUpdateSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMonitorApiV1MonitorsMonitorIdPut>>,
    { monitorId: number; data: MonitorUpdateSchema }
  > = props => {
    const { monitorId, data } = props ?? {};

    return updateMonitorApiV1MonitorsMonitorIdPut(monitorId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof updateMonitorApiV1MonitorsMonitorIdPut>>,
    TError,
    { monitorId: number; data: MonitorUpdateSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Delete monitor by id.
 * @summary Delete Monitor
 */
export const deleteMonitorApiV1MonitorsMonitorIdDelete = (monitorId: number) =>
  customInstance<unknown>({ url: `/api/v1/monitors/${monitorId}`, method: 'delete' });

export type DeleteMonitorApiV1MonitorsMonitorIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteMonitorApiV1MonitorsMonitorIdDelete>>
>;

export type DeleteMonitorApiV1MonitorsMonitorIdDeleteMutationError = ErrorType<HTTPValidationError>;

export const useDeleteMonitorApiV1MonitorsMonitorIdDelete = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteMonitorApiV1MonitorsMonitorIdDelete>>,
    TError,
    { monitorId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteMonitorApiV1MonitorsMonitorIdDelete>>,
    { monitorId: number }
  > = props => {
    const { monitorId } = props ?? {};

    return deleteMonitorApiV1MonitorsMonitorIdDelete(monitorId);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteMonitorApiV1MonitorsMonitorIdDelete>>,
    TError,
    { monitorId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Run a monitor for each time window by lookback.

Parameters
----------
monitor_id : int
    ID of the monitor.
body
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
CheckSchema
    Created check.
 * @summary Run Monitor Lookback
 */
export const runMonitorLookbackApiV1MonitorsMonitorIdRunPost = (
  monitorId: number,
  monitorRunSchema: MonitorRunSchema
) =>
  customInstance<CheckResultSchema>({
    url: `/api/v1/monitors/${monitorId}/run`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: monitorRunSchema
  });

export type RunMonitorLookbackApiV1MonitorsMonitorIdRunPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof runMonitorLookbackApiV1MonitorsMonitorIdRunPost>>
>;
export type RunMonitorLookbackApiV1MonitorsMonitorIdRunPostMutationBody = MonitorRunSchema;
export type RunMonitorLookbackApiV1MonitorsMonitorIdRunPostMutationError = ErrorType<HTTPValidationError>;

export const useRunMonitorLookbackApiV1MonitorsMonitorIdRunPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runMonitorLookbackApiV1MonitorsMonitorIdRunPost>>,
    TError,
    { monitorId: number; data: MonitorRunSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runMonitorLookbackApiV1MonitorsMonitorIdRunPost>>,
    { monitorId: number; data: MonitorRunSchema }
  > = props => {
    const { monitorId, data } = props ?? {};

    return runMonitorLookbackApiV1MonitorsMonitorIdRunPost(monitorId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runMonitorLookbackApiV1MonitorsMonitorIdRunPost>>,
    TError,
    { monitorId: number; data: MonitorRunSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Get dashboard by if exists, if not then create it. Add top 5 unassigned monitors to the dashboard if empty.
 * @summary Get Dashboard
 */
export const getDashboardApiV1DashboardsGet = (signal?: AbortSignal) =>
  customInstance<DashboardSchema>({ url: `/api/v1/dashboards/`, method: 'get', signal });

export const getGetDashboardApiV1DashboardsGetQueryKey = () => [`/api/v1/dashboards/`];

export type GetDashboardApiV1DashboardsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDashboardApiV1DashboardsGet>>
>;
export type GetDashboardApiV1DashboardsGetQueryError = ErrorType<unknown>;

export const useGetDashboardApiV1DashboardsGet = <
  TData = Awaited<ReturnType<typeof getDashboardApiV1DashboardsGet>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getDashboardApiV1DashboardsGet>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDashboardApiV1DashboardsGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDashboardApiV1DashboardsGet>>> = ({ signal }) =>
    getDashboardApiV1DashboardsGet(signal);

  const query = useQuery<Awaited<ReturnType<typeof getDashboardApiV1DashboardsGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Update dashboard by id.
 * @summary Update Dashboard
 */
export const updateDashboardApiV1DashboardsDashboardIdPut = (
  dashboardId: number,
  dashboardUpdateSchema: DashboardUpdateSchema
) =>
  customInstance<unknown>({
    url: `/api/v1/dashboards/${dashboardId}`,
    method: 'put',
    headers: { 'Content-Type': 'application/json' },
    data: dashboardUpdateSchema
  });

export type UpdateDashboardApiV1DashboardsDashboardIdPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateDashboardApiV1DashboardsDashboardIdPut>>
>;
export type UpdateDashboardApiV1DashboardsDashboardIdPutMutationBody = DashboardUpdateSchema;
export type UpdateDashboardApiV1DashboardsDashboardIdPutMutationError = ErrorType<HTTPValidationError>;

export const useUpdateDashboardApiV1DashboardsDashboardIdPut = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDashboardApiV1DashboardsDashboardIdPut>>,
    TError,
    { dashboardId: number; data: DashboardUpdateSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDashboardApiV1DashboardsDashboardIdPut>>,
    { dashboardId: number; data: DashboardUpdateSchema }
  > = props => {
    const { dashboardId, data } = props ?? {};

    return updateDashboardApiV1DashboardsDashboardIdPut(dashboardId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof updateDashboardApiV1DashboardsDashboardIdPut>>,
    TError,
    { dashboardId: number; data: DashboardUpdateSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Delete dashboard by id.
 * @summary Delete Dashboard
 */
export const deleteDashboardApiV1DashboardsDashboardIdDelete = (dashboardId: number) =>
  customInstance<unknown>({ url: `/api/v1/dashboards/${dashboardId}`, method: 'delete' });

export type DeleteDashboardApiV1DashboardsDashboardIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteDashboardApiV1DashboardsDashboardIdDelete>>
>;

export type DeleteDashboardApiV1DashboardsDashboardIdDeleteMutationError = ErrorType<HTTPValidationError>;

export const useDeleteDashboardApiV1DashboardsDashboardIdDelete = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteDashboardApiV1DashboardsDashboardIdDelete>>,
    TError,
    { dashboardId: number },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteDashboardApiV1DashboardsDashboardIdDelete>>,
    { dashboardId: number }
  > = props => {
    const { dashboardId } = props ?? {};

    return deleteDashboardApiV1DashboardsDashboardIdDelete(dashboardId);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteDashboardApiV1DashboardsDashboardIdDelete>>,
    TError,
    { dashboardId: number },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * This API logs asynchronously a batch of new samples of the inference data of an existing model version, it requires the actual data and validates it matches the version schema.
 * @summary Log inference data per model version.
 */
export const logDataBatchApiV1ModelVersionsModelVersionIdDataPost = (
  modelVersionId: number,
  logDataBatchApiV1ModelVersionsModelVersionIdDataPostBodyItem: LogDataBatchApiV1ModelVersionsModelVersionIdDataPostBodyItem[]
) =>
  customInstance<unknown>({
    url: `/api/v1/model-versions/${modelVersionId}/data`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: logDataBatchApiV1ModelVersionsModelVersionIdDataPostBodyItem
  });

export type LogDataBatchApiV1ModelVersionsModelVersionIdDataPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof logDataBatchApiV1ModelVersionsModelVersionIdDataPost>>
>;
export type LogDataBatchApiV1ModelVersionsModelVersionIdDataPostMutationBody =
  LogDataBatchApiV1ModelVersionsModelVersionIdDataPostBodyItem[];
export type LogDataBatchApiV1ModelVersionsModelVersionIdDataPostMutationError = ErrorType<HTTPValidationError>;

export const useLogDataBatchApiV1ModelVersionsModelVersionIdDataPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logDataBatchApiV1ModelVersionsModelVersionIdDataPost>>,
    TError,
    { modelVersionId: number; data: LogDataBatchApiV1ModelVersionsModelVersionIdDataPostBodyItem[] },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof logDataBatchApiV1ModelVersionsModelVersionIdDataPost>>,
    { modelVersionId: number; data: LogDataBatchApiV1ModelVersionsModelVersionIdDataPostBodyItem[] }
  > = props => {
    const { modelVersionId, data } = props ?? {};

    return logDataBatchApiV1ModelVersionsModelVersionIdDataPost(modelVersionId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof logDataBatchApiV1ModelVersionsModelVersionIdDataPost>>,
    TError,
    { modelVersionId: number; data: LogDataBatchApiV1ModelVersionsModelVersionIdDataPostBodyItem[] },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Update data samples.

Parameters
----------
request
model_version_id
data
session
data_ingest
 * @summary Update Data Batch
 */
export const updateDataBatchApiV1ModelVersionsModelVersionIdDataPut = (
  modelVersionId: number,
  updateDataBatchApiV1ModelVersionsModelVersionIdDataPutBodyItem: UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutBodyItem[]
) =>
  customInstance<unknown>({
    url: `/api/v1/model-versions/${modelVersionId}/data`,
    method: 'put',
    headers: { 'Content-Type': 'application/json' },
    data: updateDataBatchApiV1ModelVersionsModelVersionIdDataPutBodyItem
  });

export type UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateDataBatchApiV1ModelVersionsModelVersionIdDataPut>>
>;
export type UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutMutationBody =
  UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutBodyItem[];
export type UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutMutationError = ErrorType<HTTPValidationError>;

export const useUpdateDataBatchApiV1ModelVersionsModelVersionIdDataPut = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDataBatchApiV1ModelVersionsModelVersionIdDataPut>>,
    TError,
    { modelVersionId: number; data: UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutBodyItem[] },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDataBatchApiV1ModelVersionsModelVersionIdDataPut>>,
    { modelVersionId: number; data: UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutBodyItem[] }
  > = props => {
    const { modelVersionId, data } = props ?? {};

    return updateDataBatchApiV1ModelVersionsModelVersionIdDataPut(modelVersionId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof updateDataBatchApiV1ModelVersionsModelVersionIdDataPut>>,
    TError,
    { modelVersionId: number; data: UpdateDataBatchApiV1ModelVersionsModelVersionIdDataPutBodyItem[] },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * This API uploads asynchronously a reference data file for a given model version,it requires the actual data and validates it matches the version schema.
 * @summary Upload reference data for a given model version.
 */
export const saveReferenceApiV1ModelVersionsModelVersionIdReferencePost = (
  modelVersionId: number,
  bodySaveReferenceApiV1ModelVersionsModelVersionIdReferencePost: BodySaveReferenceApiV1ModelVersionsModelVersionIdReferencePost
) => {
  const formData = new FormData();
  formData.append('file', bodySaveReferenceApiV1ModelVersionsModelVersionIdReferencePost.file);

  return customInstance<unknown>({
    url: `/api/v1/model-versions/${modelVersionId}/reference`,
    method: 'post',
    headers: { 'Content-Type': 'multipart/form-data' },
    data: formData
  });
};

export type SaveReferenceApiV1ModelVersionsModelVersionIdReferencePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof saveReferenceApiV1ModelVersionsModelVersionIdReferencePost>>
>;
export type SaveReferenceApiV1ModelVersionsModelVersionIdReferencePostMutationBody =
  BodySaveReferenceApiV1ModelVersionsModelVersionIdReferencePost;
export type SaveReferenceApiV1ModelVersionsModelVersionIdReferencePostMutationError = ErrorType<HTTPValidationError>;

export const useSaveReferenceApiV1ModelVersionsModelVersionIdReferencePost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveReferenceApiV1ModelVersionsModelVersionIdReferencePost>>,
    TError,
    { modelVersionId: number; data: BodySaveReferenceApiV1ModelVersionsModelVersionIdReferencePost },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveReferenceApiV1ModelVersionsModelVersionIdReferencePost>>,
    { modelVersionId: number; data: BodySaveReferenceApiV1ModelVersionsModelVersionIdReferencePost }
  > = props => {
    const { modelVersionId, data } = props ?? {};

    return saveReferenceApiV1ModelVersionsModelVersionIdReferencePost(modelVersionId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof saveReferenceApiV1ModelVersionsModelVersionIdReferencePost>>,
    TError,
    { modelVersionId: number; data: BodySaveReferenceApiV1ModelVersionsModelVersionIdReferencePost },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Create a new model with its name, task type, and description. Returns the ID of the model.
 * @summary Create a new model.
 */
export const createModelApiV1ModelsPost = (modelCreationSchema: ModelCreationSchema) =>
  customInstance<IdResponse>({
    url: `/api/v1/models`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: modelCreationSchema
  });

export type CreateModelApiV1ModelsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createModelApiV1ModelsPost>>
>;
export type CreateModelApiV1ModelsPostMutationBody = ModelCreationSchema;
export type CreateModelApiV1ModelsPostMutationError = ErrorType<HTTPValidationError>;

export const useCreateModelApiV1ModelsPost = <TError = ErrorType<HTTPValidationError>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createModelApiV1ModelsPost>>,
    TError,
    { data: ModelCreationSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createModelApiV1ModelsPost>>,
    { data: ModelCreationSchema }
  > = props => {
    const { data } = props ?? {};

    return createModelApiV1ModelsPost(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof createModelApiV1ModelsPost>>,
    TError,
    { data: ModelCreationSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Retrieve models data ingestion status.
 * @summary Retrieve Models Data Ingestion
 */
export const retrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGet = (
  modelId: number,
  params?: RetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGetParams,
  signal?: AbortSignal
) =>
  customInstance<ModelDailyIngestion[]>({
    url: `/api/v1/models/${modelId}/data-ingestion`,
    method: 'get',
    params,
    signal
  });

export const getRetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGetQueryKey = (
  modelId: number,
  params?: RetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGetParams
) => [`/api/v1/models/${modelId}/data-ingestion`, ...(params ? [params] : [])];

export type RetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGet>>
>;
export type RetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGetQueryError = ErrorType<HTTPValidationError>;

export const useRetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGet = <
  TData = Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  modelId: number,
  params?: RetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGetParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGet>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRetrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGetQueryKey(modelId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGet>>
  > = ({ signal }) => retrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGet(modelId, params, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsModelIdDataIngestionGet>>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!modelId, ...queryOptions }) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * Retrieve models data ingestion status.
 * @summary Retrieve Models Data Ingestion
 */
export const retrieveModelsDataIngestionApiV1ModelsDataIngestionGet = (
  params?: RetrieveModelsDataIngestionApiV1ModelsDataIngestionGetParams,
  signal?: AbortSignal
) =>
  customInstance<RetrieveModelsDataIngestionApiV1ModelsDataIngestionGet200>({
    url: `/api/v1/models/data-ingestion`,
    method: 'get',
    params,
    signal
  });

export const getRetrieveModelsDataIngestionApiV1ModelsDataIngestionGetQueryKey = (
  params?: RetrieveModelsDataIngestionApiV1ModelsDataIngestionGetParams
) => [`/api/v1/models/data-ingestion`, ...(params ? [params] : [])];

export type RetrieveModelsDataIngestionApiV1ModelsDataIngestionGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsDataIngestionGet>>
>;
export type RetrieveModelsDataIngestionApiV1ModelsDataIngestionGetQueryError = ErrorType<HTTPValidationError>;

export const useRetrieveModelsDataIngestionApiV1ModelsDataIngestionGet = <
  TData = Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsDataIngestionGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  params?: RetrieveModelsDataIngestionApiV1ModelsDataIngestionGetParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsDataIngestionGet>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRetrieveModelsDataIngestionApiV1ModelsDataIngestionGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsDataIngestionGet>>> = ({
    signal
  }) => retrieveModelsDataIngestionApiV1ModelsDataIngestionGet(params, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof retrieveModelsDataIngestionApiV1ModelsDataIngestionGet>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Create a new model.

Parameters
----------
model_id : int
    Model to return.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
ModelSchema
    Created model.
 * @summary Get Model
 */
export const getModelApiV1ModelsModelIdGet = (modelId: number, signal?: AbortSignal) =>
  customInstance<ModelSchema>({ url: `/api/v1/models/${modelId}`, method: 'get', signal });

export const getGetModelApiV1ModelsModelIdGetQueryKey = (modelId: number) => [`/api/v1/models/${modelId}`];

export type GetModelApiV1ModelsModelIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getModelApiV1ModelsModelIdGet>>
>;
export type GetModelApiV1ModelsModelIdGetQueryError = ErrorType<HTTPValidationError>;

export const useGetModelApiV1ModelsModelIdGet = <
  TData = Awaited<ReturnType<typeof getModelApiV1ModelsModelIdGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  modelId: number,
  options?: { query?: UseQueryOptions<Awaited<ReturnType<typeof getModelApiV1ModelsModelIdGet>>, TError, TData> }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetModelApiV1ModelsModelIdGetQueryKey(modelId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getModelApiV1ModelsModelIdGet>>> = ({ signal }) =>
    getModelApiV1ModelsModelIdGet(modelId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getModelApiV1ModelsModelIdGet>>, TError, TData>(queryKey, queryFn, {
    enabled: !!modelId,
    ...queryOptions
  }) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Create a new model.

Parameters
----------
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
List[ModelsInfoSchema]
    List of models.
 * @summary Get Models
 */
export const getModelsApiV1ModelsGet = (signal?: AbortSignal) =>
  customInstance<ModelsInfoSchema[]>({ url: `/api/v1/models/`, method: 'get', signal });

export const getGetModelsApiV1ModelsGetQueryKey = () => [`/api/v1/models/`];

export type GetModelsApiV1ModelsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getModelsApiV1ModelsGet>>>;
export type GetModelsApiV1ModelsGetQueryError = ErrorType<unknown>;

export const useGetModelsApiV1ModelsGet = <
  TData = Awaited<ReturnType<typeof getModelsApiV1ModelsGet>>,
  TError = ErrorType<unknown>
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getModelsApiV1ModelsGet>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetModelsApiV1ModelsGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getModelsApiV1ModelsGet>>> = ({ signal }) =>
    getModelsApiV1ModelsGet(signal);

  const query = useQuery<Awaited<ReturnType<typeof getModelsApiV1ModelsGet>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Get statistics of columns for model.

Parameters
----------
model_id : int
    Model get columns for.
session : AsyncSession, optional
    SQLAlchemy session.

Returns
-------
Dict[str, ColumnMetadata]
    Column name and metadata (type and value if available).
 * @summary Get Model Columns
 */
export const getModelColumnsApiV1ModelsModelIdColumnsGet = (modelId: number, signal?: AbortSignal) =>
  customInstance<GetModelColumnsApiV1ModelsModelIdColumnsGet200>({
    url: `/api/v1/models/${modelId}/columns`,
    method: 'get',
    signal
  });

export const getGetModelColumnsApiV1ModelsModelIdColumnsGetQueryKey = (modelId: number) => [
  `/api/v1/models/${modelId}/columns`
];

export type GetModelColumnsApiV1ModelsModelIdColumnsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getModelColumnsApiV1ModelsModelIdColumnsGet>>
>;
export type GetModelColumnsApiV1ModelsModelIdColumnsGetQueryError = ErrorType<HTTPValidationError>;

export const useGetModelColumnsApiV1ModelsModelIdColumnsGet = <
  TData = Awaited<ReturnType<typeof getModelColumnsApiV1ModelsModelIdColumnsGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  modelId: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getModelColumnsApiV1ModelsModelIdColumnsGet>>, TError, TData>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetModelColumnsApiV1ModelsModelIdColumnsGetQueryKey(modelId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getModelColumnsApiV1ModelsModelIdColumnsGet>>> = ({
    signal
  }) => getModelColumnsApiV1ModelsModelIdColumnsGet(modelId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getModelColumnsApiV1ModelsModelIdColumnsGet>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!modelId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Create a new model version.

Parameters
----------
request
model_id : int
    ID of the model.
info : VersionInfo
    Information about the model version.
session : AsyncSession, optional
    SQLAlchemy session.
kafka_admin
settings
data_ingest
 * @summary Create Version
 */
export const createVersionApiV1ModelsModelIdVersionPost = (
  modelId: number,
  modelVersionCreationSchema: ModelVersionCreationSchema
) =>
  customInstance<IdResponse>({
    url: `/api/v1/models/${modelId}/version`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: modelVersionCreationSchema
  });

export type CreateVersionApiV1ModelsModelIdVersionPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createVersionApiV1ModelsModelIdVersionPost>>
>;
export type CreateVersionApiV1ModelsModelIdVersionPostMutationBody = ModelVersionCreationSchema;
export type CreateVersionApiV1ModelsModelIdVersionPostMutationError = ErrorType<HTTPValidationError>;

export const useCreateVersionApiV1ModelsModelIdVersionPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createVersionApiV1ModelsModelIdVersionPost>>,
    TError,
    { modelId: number; data: ModelVersionCreationSchema },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createVersionApiV1ModelsModelIdVersionPost>>,
    { modelId: number; data: ModelVersionCreationSchema }
  > = props => {
    const { modelId, data } = props ?? {};

    return createVersionApiV1ModelsModelIdVersionPost(modelId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof createVersionApiV1ModelsModelIdVersionPost>>,
    TError,
    { modelId: number; data: ModelVersionCreationSchema },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * Return json schema of the model version data to use in validation on client-side.

Parameters
----------
model_version_id
session

Returns
-------
json schema of the model version
 * @summary Get Schema
 */
export const getSchemaApiV1ModelVersionsModelVersionIdSchemaGet = (modelVersionId: number, signal?: AbortSignal) =>
  customInstance<unknown>({ url: `/api/v1/model-versions/${modelVersionId}/schema`, method: 'get', signal });

export const getGetSchemaApiV1ModelVersionsModelVersionIdSchemaGetQueryKey = (modelVersionId: number) => [
  `/api/v1/model-versions/${modelVersionId}/schema`
];

export type GetSchemaApiV1ModelVersionsModelVersionIdSchemaGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSchemaApiV1ModelVersionsModelVersionIdSchemaGet>>
>;
export type GetSchemaApiV1ModelVersionsModelVersionIdSchemaGetQueryError = ErrorType<HTTPValidationError>;

export const useGetSchemaApiV1ModelVersionsModelVersionIdSchemaGet = <
  TData = Awaited<ReturnType<typeof getSchemaApiV1ModelVersionsModelVersionIdSchemaGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  modelVersionId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getSchemaApiV1ModelVersionsModelVersionIdSchemaGet>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSchemaApiV1ModelVersionsModelVersionIdSchemaGetQueryKey(modelVersionId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSchemaApiV1ModelVersionsModelVersionIdSchemaGet>>> = ({
    signal
  }) => getSchemaApiV1ModelVersionsModelVersionIdSchemaGet(modelVersionId, signal);

  const query = useQuery<Awaited<ReturnType<typeof getSchemaApiV1ModelVersionsModelVersionIdSchemaGet>>, TError, TData>(
    queryKey,
    queryFn,
    { enabled: !!modelVersionId, ...queryOptions }
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};

/**
 * Return json schema of the model version data to use in validation on client-side.

Parameters
----------
model_version_id
session

Returns
-------
json schema of the model version
 * @summary Get Reference Schema
 */
export const getReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGet = (
  modelVersionId: number,
  signal?: AbortSignal
) =>
  customInstance<unknown>({ url: `/api/v1/model-versions/${modelVersionId}/reference-schema`, method: 'get', signal });

export const getGetReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGetQueryKey = (
  modelVersionId: number
) => [`/api/v1/model-versions/${modelVersionId}/reference-schema`];

export type GetReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGet>>
>;
export type GetReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGetQueryError =
  ErrorType<HTTPValidationError>;

export const useGetReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGet = <
  TData = Awaited<ReturnType<typeof getReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGet>>,
  TError = ErrorType<HTTPValidationError>
>(
  modelVersionId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGet>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGetQueryKey(modelVersionId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGet>>
  > = ({ signal }) => getReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGet(modelVersionId, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof getReferenceSchemaApiV1ModelVersionsModelVersionIdReferenceSchemaGet>>,
    TError,
    TData
  >(queryKey, queryFn, { enabled: !!modelVersionId, ...queryOptions }) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryKey;

  return query;
};

/**
 * Run suite (all checks defined) on given model version.

Parameters
----------
model_version_id
monitor_options
session

Returns
-------
HTML of the suite result.
 * @summary Run Suite On Model Version
 */
export const runSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPost = (
  modelVersionId: number,
  monitorOptions: MonitorOptions
) =>
  customInstance<string>({
    url: `/api/v1/model-versions/${modelVersionId}/suite-run`,
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    data: monitorOptions
  });

export type RunSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof runSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPost>>
>;
export type RunSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPostMutationBody = MonitorOptions;
export type RunSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPostMutationError =
  ErrorType<HTTPValidationError>;

export const useRunSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof runSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPost>>,
    TError,
    { modelVersionId: number; data: MonitorOptions },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof runSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPost>>,
    { modelVersionId: number; data: MonitorOptions }
  > = props => {
    const { modelVersionId, data } = props ?? {};

    return runSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPost(modelVersionId, data);
  };

  return useMutation<
    Awaited<ReturnType<typeof runSuiteOnModelVersionApiV1ModelVersionsModelVersionIdSuiteRunPost>>,
    TError,
    { modelVersionId: number; data: MonitorOptions },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * @summary
 */
export const get = (signal?: AbortSignal) => customInstance<unknown>({ url: `/`, method: 'get', signal });

export const getGetQueryKey = () => [`/`];

export type GetQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>;
export type GetQueryError = ErrorType<unknown>;

export const useGet = <TData = Awaited<ReturnType<typeof get>>, TError = ErrorType<unknown>>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({ signal }) => get(signal);

  const query = useQuery<Awaited<ReturnType<typeof get>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  ) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryKey;

  return query;
};
