# ----------------------------------------------------------------------------
# Copyright (C) 2021-2022 Deepchecks (https://www.deepchecks.com)
#
# This file is part of Deepchecks.
# Deepchecks is distributed under the terms of the GNU Affero General
# Public License (version 3 or later).
# You should have received a copy of the GNU Affero General Public License
# along with Deepchecks.  If not, see <http://www.gnu.org/licenses/>.
# ----------------------------------------------------------------------------
"""frequency enumeration

Revision ID: 29e9ef85d8fd
Revises: 294d2b30b20b
Create Date: 2023-03-21 12:27:43.065191

"""
import sqlalchemy as sa
from alembic import op

# revision identifiers, used by Alembic.
revision = '29e9ef85d8fd'
down_revision = '294d2b30b20b'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    from deepchecks_monitoring.schema_models.monitor import NUM_WINDOWS_TO_START, Frequency

    # ==== Drop monitors check constraints ====

    op.drop_constraint(constraint_name="frequency_valid", table_name="monitors")
    op.drop_constraint(constraint_name="aggregation_window_valid", table_name="monitors")

    # ==== Convert frequencies to enum values ====

    op.execute("CREATE TYPE frequency AS ENUM('HOUR', 'DAY', 'WEEK', 'MONTH')")

    op.add_column(
        table_name="monitors",
        column=sa.Column("frequency_enum", sa.Enum(Frequency), nullable=True)
    )

    op.execute("""
        with
            data as (
                select
                    id as monitor_id,
                    case
                        when frequency >= 2592000 then 'MONTH'::frequency
                        when frequency >= 604800  then 'WEEK'::frequency
                        when frequency >= 86400   then 'DAY'::frequency
                        when frequency >= 3600    then 'HOUR'::frequency
                        else 'HOUR'::frequency
                    end as frequency_value
                from monitors
                for update
            )
        update monitors
        set frequency_enum = data.frequency_value
        from data
        where id = data.monitor_id
    """)

    op.drop_column(table_name="monitors", column_name="frequency")
    op.alter_column(table_name="monitors", column_name="frequency_enum", new_column_name="frequency", nullable=False)

    # ==== Reset monitors state ====
    # TODO: we need a universal api for monitors reset

    op.execute(sa.text("""
        with
            monitors_data as (
                select
                    monitors.id as monitor_id,
                    new_latest_schedule.v as new_latest_schedule
                from monitors
                join checks on checks.id = monitors.check_id
                join models on checks.model_id = models.id
                join lateral (
                    select concat('1 ', frequency::varchar)::interval
                ) as converted_frequency(v) on true
                join lateral (
                    select converted_frequency.v * :num_windows_to_start
                ) as lookback(v) on true
                join lateral (
                    select case
                        when models.end_time < models.start_time then now() - lookback.v
                        else least(
                            models.end_time - lookback.v,
                            monitors.latest_schedule
                        )
                    end
                ) as unrounded_latest_schedule(v) on true
                join lateral (
                    select date_trunc(frequency::varchar, unrounded_latest_schedule.v) + converted_frequency.v
                ) as new_latest_schedule(v) on true
                for update of monitors
            ),
            updated_monitors as (
                update monitors
                set latest_schedule = new_latest_schedule
                from monitors_data
                where id = monitors_data.monitor_id
                returning monitors.id, monitors.latest_schedule
            ),
            updated_alert_rules as (
                update alert_rules
                set start_time = null
                where monitor_id in (select id from updated_monitors)
                returning id
            ),
            deleted_alerts as (
                delete from alerts
                using updated_alert_rules
                where alert_rule_id = updated_alert_rules.id
                returning alerts.id
            ),
            deleted_tasks as (
                delete from tasks
                using updated_monitors
                where
                    (tasks.params ->> 'timestamp')::timestamptz > updated_monitors.latest_schedule
                    and (tasks.params -> 'monitor_id')::integer = updated_monitors.id
                returning tasks.id
            )
        select
            (select jsonb_agg(id) from updated_monitors) as updated_monitors,
            (select jsonb_agg(id) from updated_alert_rules) as updated_alert_rules,
            (select jsonb_agg(id) from deleted_alerts) as deleted_alerts,
            (select jsonb_agg(id) from deleted_tasks) as deleted_tasks
    """).bindparams(
        sa.bindparam("num_windows_to_start", type_=sa.INTEGER, value=NUM_WINDOWS_TO_START),
    ))

    # === Recalculate aggregation window value ===

    op.execute("""
        update monitors
        set aggregation_window = case
            when frequency = 'HOUR'::frequency then ceil(aggregation_window / 3600)
            when frequency = 'DAY'::frequency then ceil(aggregation_window / 86400)
            when frequency = 'WEEK'::frequency then ceil(aggregation_window / 604800)
            when frequency = 'MONTH'::frequency then ceil(aggregation_window / 2592000)
            else 1
        end
    """)

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    from deepchecks_monitoring.schema_models.monitor import NUM_WINDOWS_TO_START

    # ==== Convert frequencies back to seconds ====

    op.add_column(
        table_name="monitors",
        column=sa.Column("frequency_seconds", sa.Integer(), nullable=True)
    )

    op.execute("""
        with data as (
            select
                id as monitor_id,
                case
                    when frequency = 'HOUR'  then 3600
                    when frequency = 'DAY'   then 86400
                    when frequency = 'WEEK'  then 604800
                    when frequency = 'MONTH' then 2592000
                    else 2592000
                end as frequency_value
            from monitors
            for update
        )
        update monitors
        set frequency_seconds = data.frequency_value
        from data
        where id = data.monitor_id
    """)

    op.drop_column(table_name="monitors", column_name="frequency")
    op.alter_column(table_name="monitors", column_name="frequency_seconds", new_column_name="frequency", nullable=False)

    # ==== Reset monitors state ====

    op.execute(sa.text("""
        with
            monitors_data as (
                select
                    monitors.id as monitor_id,
                    new_latest_schedule.v as new_latest_schedule
                from monitors
                join checks on checks.id = monitors.check_id
                join models on checks.model_id = models.id
                join lateral (
                    select concat(monitors.frequency * :num_windows_to_start, ' seconds')::interval
                ) as lookback(v) on true
                join lateral (
                    select case
                        when models.end_time < models.start_time then now() - lookback.v
                        else least(
                            models.end_time - lookback.v,
                            monitors.latest_schedule
                        )
                    end
                ) as unrounded_latest_schedule(v) on true
                join lateral (
                    select to_timestamp(
                        div(
                            extract(epoch from unrounded_latest_schedule.v)::integer,
                            monitors.frequency
                        ) * monitors.frequency
                    )
                ) as new_latest_schedule(v) on true
                for update of monitors
            ),
            updated_monitors as (
                update monitors
                set latest_schedule = new_latest_schedule
                from monitors_data
                where id = monitors_data.monitor_id
                returning monitors.id, monitors.latest_schedule
            ),
            updated_alert_rules as (
                update alert_rules
                set start_time = null
                where monitor_id in (select id from updated_monitors)
                returning id
            ),
            deleted_alerts as (
                delete from alerts
                using updated_alert_rules
                where alert_rule_id = updated_alert_rules.id
                returning alerts.id
            ),
            deleted_tasks as (
                delete from tasks
                using updated_monitors
                where
                    (tasks.params ->> 'timestamp')::timestamptz > updated_monitors.latest_schedule
                    and (tasks.params -> 'monitor_id')::integer = updated_monitors.id
                returning tasks.id
            )
        select
            (select jsonb_agg(id) from updated_monitors) as updated_monitors,
            (select jsonb_agg(id) from updated_alert_rules) as updated_alert_rules,
            (select jsonb_agg(id) from deleted_alerts) as deleted_alerts,
            (select jsonb_agg(id) from deleted_tasks) as deleted_tasks
    """).bindparams(
        sa.bindparam("num_windows_to_start", type_=sa.INTEGER, value=NUM_WINDOWS_TO_START),
    ))

    # === Reset aggregation window ====

    op.execute("""
        update monitors
        set aggregation_window = frequency * aggregation_window
    """)

    # ==== Recreate monitors check constraints ====

    op.create_check_constraint(
        constraint_name="aggregation_window_valid",
        table_name="monitors",
        condition="""
        aggregation_window >= 3600
        AND aggregation_window % 3600 = 0
        AND aggregation_window >= frequency
        """
    )
    op.create_check_constraint(
        constraint_name="frequency_valid",
        table_name="monitors",
        condition="frequency >= 3600 AND frequency % 3600 = 0"
    )

    # ====

    op.execute("DROP TYPE frequency")
    # ### end Alembic commands ###
